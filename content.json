{"meta":{"title":"YlwBlog","subtitle":null,"description":"Keep learning!","author":"Yuliwen","url":"https://batuer.github.io"},"pages":[],"posts":[{"title":"Android进程保活Service常驻","slug":"Android进程、Service保活","date":"2018-06-26T14:12:56.751Z","updated":"2018-06-26T16:14:45.445Z","comments":true,"path":"2018/06/26/Android进程、Service保活/","link":"","permalink":"https://batuer.github.io/2018/06/26/Android进程、Service保活/","excerpt":"","text":"https://mp.weixin.qq.com/s/OXiFQNTyCHpqSP6B9HOiHw 进程保活进程保活两个层面： 提高进程优先级，降低被系统杀死概率。 进程被杀死后，进行拉活。 进程的优先级 前台进程：前台进程不多，内存不足时系统才会清理。 正在可交互的Activity(onResume()和onStart()区别)。 Service绑定到正在可交互的Activity。 前台Service 123public final void startForeground(int id, Notification notification) &#123;&#125;public ComponentName startForegroundService(Intent service) &#123;&#125; 正执行生命周期的Service。 正执行生命周期的BroadcastReceiver。 可见进程：可见不可交互的进程。 Activity执行onStart()未执行onStop()。 Service绑定到可见的Activity。 服务进程：进程中有Service正在运行。 后台进程：进程最后一个Activity执行onStop()。 空进程：这种进程唯一目的用作缓存，缩短下次启动时间。 提升进程优先级利用Activity提升权限 监控解锁屏事件，锁屏时启动1个像素的透明Activity，解锁时销毁。 可以使进程变为可见进程。 利用Notification提升权限 普通服务进程升级为前台进程，会在通知栏有通知，用户可感知。 通过实现一个内部 Service，在 LiveService 和其内部 Service 中同时发送具有相同 ID 的 Notification，然后将内部 Service 结束掉。随着内部 Service 的结束，Notification 将会消失，但系统优先级依然保持为2。 进程杀死后拉活利用系统广播 注册静态广播监听系统广播事件。 广播管理器会被系统软件或管理软件禁用进而无法接收到广播。 系统广播事件不可控。 利用第三方应用广播 反编译监听第三方应用会发送的广播。 存在第三方广播会升级修改，不能及时通知。 利用系统Service机制拉活 1234@Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return Service.START_STICKY; &#125; Service 第一次被异常杀死后会在5秒内重启，第二次被杀死会在10秒内重启，第三次会在20秒内重启，一旦在短时间内 Service 被杀死达到5次，则系统不再拉起。 进程被取得 Root 权限的管理工具或系统工具通过 forestop 停止掉，无法重启。 利用Native进程拉活 利用 Linux 中的 fork 机制创建 Native 进程，在 Native 进程中监控主进程的存活，当主进程挂掉后，在 Native 进程中立即对主进程进行拉活。 …… 利用JobScheduler机制拉活 Android5.0 以后系统对 Native 进程等加强了管理，Native 拉活方式失效。系统在 Android5.0 以上版本提供了 JobScheduler 接口，系统会定时调用该进程以使应用进行一些逻辑操作。 利用账号同步机制 Android 系统的账号同步机制会定期同步账号进行，该方案目的在于利用同步机制进行进程的拉活。 该方案适用于所有的 Android 版本，包括被 forestop 掉的进程也可以进行拉活。 最新 Android 版本（Android N）中系统好像对账户同步这里做了变动，该方法不再有效。 其它方案 利用系统通知管理权限进行拉活 。 利用辅助功能拉活，将应用加入厂商或管理软件白名单。 根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。 Service常驻 JNI：5.0以前，Android系统本身不管理JNI层的，用Linux的Fork机制将App和进程分开。 JobService：可以在自动创建进程后台干任何事情，包括拉活activity、service或者执行任何的代码。但JobService并不意味着你不受任何限制，比如受到doze、monitor之类的管理。 前台服务。 Service 的 onstartCommand()。","categories":[{"name":"进程、Service保活","slug":"进程、Service保活","permalink":"https://batuer.github.io/categories/进程、Service保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"https://batuer.github.io/tags/进程保活/"},{"name":"Service保活","slug":"Service保活","permalink":"https://batuer.github.io/tags/Service保活/"}]},{"title":"自定义View","slug":"Android自定义View","date":"2018-05-03T00:35:45.529Z","updated":"2018-06-26T14:13:14.653Z","comments":true,"path":"2018/05/03/Android自定义View/","link":"","permalink":"https://batuer.github.io/2018/05/03/Android自定义View/","excerpt":"","text":"学习链接 View基础View分类 View，不包含子View，所有View的最基类。 ViewGroup，包含子View，也是View的子类。 View构造函数12345678910111213141516171819202122232425262728293031323334353637//代码newpublic MyView(Context context) &#123; super(context);&#125;/** * xml inflate * * @param attrs 属性集，自定义属性也从这里来 */public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs);&#125;/** * 不会主动调用 * * @param defStyleAttr style属性 *//* 1.首先获取给定的AttributeSet中的属性值 2.如果找不到，则去AttributeSet中style（你在写布局文件时定义的style=\"@style/xxxx\"）指定的资源获取 3.如果找不到，则去defStyleAttr以及defStyleRes中的默认style中获取。 4.最后去找的是当前theme下的基础值。 */public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr);&#125;/** * Api &gt;=21 * @param defStyleRes View有style属性时 */@TargetApi(Build.VERSION_CODES.LOLLIPOP)public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes);&#125; View位置(坐标) View Measure作用 某些情况下，需要多次测量才能确定View自身期望和父容器约束条件的综合值。 测量得到的值并不是View最终的值，在layout()后才能得到最终的值。getMeasureWidth()不一定等于getWidth()的原因。 Measure值影响因素ViewGroup.LayoutParams 指定View的宽高值。 1234567891011@ViewDebug.ExportedProperty(category = \"layout\", mapping = &#123; @ViewDebug.IntToString(from = MATCH_PARENT, to = \"MATCH_PARENT\"), @ViewDebug.IntToString(from = WRAP_CONTENT, to = \"WRAP_CONTENT\") &#125;) public int width; @ViewDebug.ExportedProperty(category = \"layout\", mapping = &#123; @ViewDebug.IntToString(from = MATCH_PARENT, to = \"MATCH_PARENT\"), @ViewDebug.IntToString(from = WRAP_CONTENT, to = \"WRAP_CONTENT\") &#125;) public int height; MeasureSpec 简介 定义：测量规格类(测量View大小的指导参数)。 作用：指导作用View的大小。 组成 1int measureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.EXACTLY); 12345678910//Older apps may need this compatibility hack for measurement.//sUseBrokenMakeMeasureSpec = targetSdkVersion &lt;= Build.VERSION_CODES.JELLY_BEAN_MR1;public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; 12345678910//UNSPECIFIED 父容器不约束子View，常用于系统内部 //EXACTLY 父容器指定确切值，子View应该是这个指定值 //AT_MOST 父容器提供一个最大参考值，子View根据自身测量不可超过参考值 @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;) @Retention(RetentionPolicy.SOURCE) public @interface MeasureSpecMode &#123;&#125; 结论：子View的大小由父View的MeasureSpec和自身的LayoutParams属性共同决定子View的大小。 Measure过程 View measure() 1234567891011121314//final 不支持子View重写public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... //测量 int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; //onMeasure 计算大小 onMeasure(widthMeasureSpec, heightMeasureSpec); ... &#125; else &#123; ... &#125; ... &#125; onMeasure() 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 12345678910111213141516171819202122public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; //多为系统调用，getSuggestSize case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; //backGround不为null，固有的尺寸protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; 3. setMeasuredDimension() 1234//赋值 mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight;protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; ... &#125; 4. 完成测量 ViewGroup 原理： 遍历测量所有子View的测量尺寸。 合并所有子View的尺寸得到ViewGroup的测量尺寸。 过程： measure() 1234567891011121314//final 不支持子View重写public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... //测量 int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; //onMeasure 计算大小 onMeasure(widthMeasureSpec, heightMeasureSpec); ... &#125; else &#123; ... &#125; ... &#125; ​ onMeasure() (必须复写,不同ViewGroup有不同的测量布局方式，直接影响ViewGroup的测量尺寸) 1234567891011@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //1.遍历测量子View的尺寸 //2.measureChild //3.getChildMeasureSpec measureChildren(widthMeasureSpec,heightMeasureSpec); //4.合并汇总的到ViewGroup的测量尺寸 int measuredWidth = 0; int measuredHeight = 0; //5.赋值 mMeasuredWidth、mMeasuredHeight setMeasuredDimension(measuredWidth,measuredHeight); &#125; ​ measureChildren() 12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; ​ measureChild() 123456789101112131415161718192021222324 protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125;//自身LayoutParams，可以复写为子View添加自定义属性 @Override protected boolean checkLayoutParams(ViewGroup.LayoutParams p) &#123; return p instanceof LayoutParams; &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new LayoutParams(getContext(), attrs); &#125; @Override protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) &#123; return new LayoutParams(p); &#125; ​ getChildMeasureSpec() 12345678910111213141516final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; ... return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; ​ 遍历子View测量并汇总，ViewGroup根据需求自己实现 setMeasuredDimension()​ View Layout 作用计算确定View的位置，即Left、Top、Right、Bottom的坐标。 Layout过程 View layout() 123456789101112131415161718192021222324//View本身的位置public void layout(int l, int t, int r, int b) &#123; // 当前视图的四个顶点 int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; // 1. 确定View的位置：setFrame（） / setOpticalFrame（） // 即初始化四个顶点的值、判断当前View大小和位置是否发生了变化 &amp; 返回 // -&gt;&gt;分析1、分析2 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); // 2. 若视图的大小 &amp; 位置发生变化 // 会重新确定该View所有的子View在父容器的位置：onLayout（） if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); // 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout（）是一个空实现-&gt;&gt;分析3 // 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout（）在ViewGroup为1个抽象方法，需重写实现（后面会详细说） ...&#125; ViewGroup 原理： 计算自身ViewGroup的位置：layout() 遍历子View并确定子View在ViewGroup的位置(调用子View的layout() )：onLayout() ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 //与单一View的layout（）源码一致 public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; // 1. 确定View的位置： boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); // 2. 若视图的大小 &amp; 位置发生变化 // 会重新确定该View所有的子View在父容器的位置：onLayout（） if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); // 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout（）是一个空实现（上面已分析完毕） // 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout（）在ViewGroup为1个抽象方法，需重写实现 ...&#125; //确定View本身的位置，即设置View本身的四个顶点位置 protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... &#125;//确定View本身的位置(视觉上的)，即设置View本身的四个顶点位置 private boolean setOpticalFrame(int left, int top, int right, int bottom) &#123; ... // 内部实际上是调用setFrame（） return setFrame( left + parentInsets.left - childInsets.left, top + parentInsets.top - childInsets.top, right + parentInsets.left + childInsets.right, bottom + parentInsets.top + childInsets.bottom); &#125; // 回到调用原处/** * 分析3：onLayout（） * 作用：计算该ViewGroup包含所有的子View在父容器的位置（） * 注： * a. 定义为抽象方法，需重写，因：子View的确定位置与具体布局有关，所以onLayout（）在ViewGroup没有实现 * b. 在自定义ViewGroup时必须复写onLayout（）！！！！！ * c. 复写原理：遍历子View 、计算当前子View的四个位置值 &amp; 确定自身子View的位置（调用子View layout（）） */ protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; // 参数说明 // changed 当前View的大小和位置改变了 // left 左部位置 // top 顶部位置 // right 右部位置 // bottom 底部位置 // 1. 遍历子View：循环所有子View for (int i=0; i&lt;getChildCount(); i++) &#123; View child = getChildAt(i); // 2. 计算当前子View的四个位置值 // 2.1 位置的计算逻辑 ...// 需自己实现，也是自定义View的关键 // 2.2 对计算后的位置值进行赋值 int mLeft = Left int mTop = Top int mRight = Right int mBottom = Bottom // 3. 根据上述4个位置的计算值，设置子View的4个顶点：调用子view的layout() &amp; 传递计算过的参数 // 即确定了子View在父容器的位置 child.layout(mLeft, mTop, mRight, mBottom); // 该过程类似于单一View的layout过程中的layout（）和onLayout（），此处不作过多描述 &#125; &#125; &#125; View Draw作用绘制View视图 过程 原理 View绘制自身(背景、内容)。 绘制装饰(滚动条、滚动指示器、前景等)。 流程 draw() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 源码分析：draw（） * 作用：根据给定的 Canvas 自动渲染 View（包括其所有子 View）。 * 绘制过程： * 1. 绘制view背景 * 2. 绘制view内容 * 3. 绘制子View * 4. 绘制装饰（渐变框，滑动条等等） * 注： * a. 在调用该方法之前必须要完成 layout 过程 * b. 所有的视图最终都是调用 View 的 draw （）绘制视图（ ViewGroup 没有复写此方法） * c. 在自定义View时，不应该复写该方法，而是复写 onDraw(Canvas) 方法进行绘制 * d. 若自定义的视图确实要复写该方法，那么需先调用 super.draw(canvas)完成系统的绘制，然后再进行自定义的绘制 */ public void draw(Canvas canvas) &#123; ...// 仅贴出关键代码 int saveCount; // 步骤1： 绘制本身View背景 if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // 若有必要，则保存图层（还有一个复原图层） // 优化技巧：当不需绘制 Layer 时，“保存图层“和“复原图层“这两步会跳过 // 因此在绘制时，节省 layer 可以提高绘制效率 final int viewFlags = mViewFlags; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // 步骤2：绘制本身View内容 if (!dirtyOpaque) onDraw(canvas); // View 中：默认为空实现，需复写 // ViewGroup中：需复写 // 步骤3：绘制子View // 由于单一View无子View，故View 中：默认为空实现 // ViewGroup中：系统已经复写好对其子视图进行绘制我们不需要复写 dispatchDraw(canvas); // 步骤4：绘制装饰，如滑动条、前景色等等 onDrawScrollBars(canvas); return; &#125; ... &#125; ​ drawBackground() 1234567891011121314151617181920212223/** * 步骤1：drawBackground(canvas) * 作用：绘制View本身的背景 */ private void drawBackground(Canvas canvas) &#123; // 获取背景 drawable final Drawable background = mBackground; if (background == null) &#123; return; &#125; // 根据在 layout 过程中获取的 View 的位置参数，来设置背景的边界 setBackgroundBounds(); ..... // 获取 mScrollX 和 mScrollY值 final int scrollX = mScrollX; final int scrollY = mScrollY; if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; // 若 mScrollX 和 mScrollY 有值，则对 canvas 的坐标进行偏移 canvas.translate(scrollX, scrollY); // 调用 Drawable 的 draw 方法绘制背景 background.draw(canvas); canvas.translate(-scrollX, -scrollY); } } 1234 ​3. onDraw() /** 作用：绘制View本身的内容 注： a. 由于 View 的内容各不相同，所以该方法是一个空实现 b. 在自定义绘制过程中，需由子类去实现复写该方法，从而绘制自身的内容 c. 谨记：自定义View中 必须 且 只需复写onDraw（）*/protected void onDraw(Canvas canvas) { … // 复写从而实现绘制逻辑 } 123456789101112131415161718192021222324252627282930 ​4. dispatchDraw() ```java //View 没有子View空实现 //ViewGroup protected void dispatchDraw(Canvas canvas) &#123; ...... // 1. 遍历子View final int childrenCount = mChildrenCount; ...... for (int i = 0; i &lt; childrenCount; i++) &#123; ...... if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; // 2. 绘制子View more |= drawChild(canvas, transientChild, drawingTime); &#125; .... &#125; &#125; //绘制子View protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime); &#125; ​ onDrawForeground() 1234567891011121314151617181920212223242526272829public void onDrawForeground(Canvas canvas) &#123; //滚动条指示器 onDrawScrollIndicators(canvas); //滚动条 onDrawScrollBars(canvas); //前景 final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null; if (foreground != null) &#123; if (mForegroundInfo.mBoundsChanged) &#123; mForegroundInfo.mBoundsChanged = false; final Rect selfBounds = mForegroundInfo.mSelfBounds; final Rect overlayBounds = mForegroundInfo.mOverlayBounds; if (mForegroundInfo.mInsidePadding) &#123; selfBounds.set(0, 0, getWidth(), getHeight()); &#125; else &#123; selfBounds.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom()); &#125; final int ld = getLayoutDirection(); Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(), foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld); foreground.setBounds(overlayBounds); &#125; foreground.draw(canvas); &#125; &#125; 加入自己想要绘制的内容。 View.setWillNotDraw()，标记View是否需要绘制，系统优化ViewGroup默认为true。","categories":[{"name":"Activity","slug":"Activity","permalink":"https://batuer.github.io/categories/Activity/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"View基础","slug":"View基础","permalink":"https://batuer.github.io/tags/View基础/"},{"name":"View Measure","slug":"View-Measure","permalink":"https://batuer.github.io/tags/View-Measure/"},{"name":"View Layout","slug":"View-Layout","permalink":"https://batuer.github.io/tags/View-Layout/"},{"name":"View Draw","slug":"View-Draw","permalink":"https://batuer.github.io/tags/View-Draw/"}]},{"title":"Android事件","slug":"Android事件传递","date":"2018-05-01T16:23:33.325Z","updated":"2018-05-02T00:37:28.607Z","comments":true,"path":"2018/05/02/Android事件传递/","link":"","permalink":"https://batuer.github.io/2018/05/02/Android事件传递/","excerpt":"","text":"事件一般有 MotionEvent.ACTION_DOWN MotionEvent.ACTION_UP MotionEvent.ACTION_MOVE MotionEvent.ACTION_CANCEL(触摸移出第一消费事件View外) 事件顺序Activity → ViewGroup → … →View 相应决定事件分发、拦截、消费的具体 Activity dispatchTouchEvent 1234567891011public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; //空方法，实现屏保功能，当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 onUserInteraction(); &#125; //重要！！！ 找到PhoneWindow及DecoreView，往下传递事件 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; onTouchEvent(消费事件，true消费) ViewGroup dispatchTouchEvent onInterceptTouchEvent onTouchEvent View dispatchTouchEvent onTouchEvent super很重要决定事件的下一步走向，不执行super时谨慎使用(如Activity的super.dispatchTouchEvent(ev))。","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"事件","slug":"事件","permalink":"https://batuer.github.io/tags/事件/"}]},{"title":"Binder进程通信","slug":"Binder进程通信","date":"2018-04-24T00:24:40.011Z","updated":"2018-05-03T00:37:56.637Z","comments":true,"path":"2018/04/24/Binder进程通信/","link":"","permalink":"https://batuer.github.io/2018/04/24/Binder进程通信/","excerpt":"","text":"学习链接 Binder 从机制、模型的角度 定义：Binder是Android中IPC^1的一种方式。 作用：Android中跨进程通信。 模型的结构、组成 定义：Binder是一种虚拟的物理设备驱动（Binder驱动)。 作用：连接Service进程，Client进程和ServiceManager进程。 Android代码的实现 定义：Binder是一个类，实现IBinder接口。 作用：Binder机制模型，代码的形式具体实现在Android中。 进程空间划分 一个进程空间划分成用户空间与内核空间，进程内用户与内核隔离。 区别 进程间，用户空间数据不可共享。 进程间，内核空间数据可共享。 所有进程共用一个内核空间。 进程隔离Linux机制，为了保证安全性与独立性，一个进程不能直接访问另一个进程。 IPC进程间数据交互、通信。 Binder跨进程通信机制、模型模型原理Binder跨进程通信机制基于Client -Server 模式 模型组成角色 Client进程（Android客户端）：使用服务的进程。 Server进程（服务器端）：提供服务的进程。 ServiceManager进程（类似于路由器）：管理Service注册与查询（将字符形式的Binder名字转化成Client中对该Binder的引用）。 Binder驱动（持有每个Server进程在内和空间的Binder实体，并提供Client进程Binder实体的引用）： 虚拟设备驱动，是连接Servier、Client和ServiceManager的桥梁。 传递服务进程消息。 传递进程间需要传递的数据：通过内存映射。 线程控制：采用Binder线程池，并有Binder驱动自身进行管理。 原理步骤 注册服务：ServiceManager拥有Server进程的信息。 Server进程向Binder驱动发起服务注册请求。 Binder驱动将注册请求转发给ServiceManager。 ServiceManager添加该Server进程。 获取服务：（Client进程与Server进程已建立连接） Client向Binder驱动传递要获取服务的名称，获取请求服务。 Binder驱动将请求转发给ServiceManager进程。 ServiceManager通过名称查找需要的Server信息。 通过Binder驱动将上述服务信息返回给Client进程。 使用服务 Binder驱动为跨进程通信做准备——实现内存映射。 Binder驱动创建一块接收缓存区。 根据ServiceManager进程里的Server信息找到对应的Server进程，实现内核缓存区和Server进程用户空间地址同时映射到同一个接收缓存区中。 Client进程将参数数据发送到Server进程。 Client进程通过系统调用copy_from_user()发送数据到内核空间中的缓存区（当前线程被挂起）。 由于内核缓存与接收进程的用户空间地址存在映射关系（同时映射Binder创建的接收缓存区中）相当于也发送到了Server进程的用户空间地址，即Binder驱动实现了跨进程通信。 Binder驱动通知Server进程执行解包。 Server进程将参数数据发送到Serve进程。 收到BInder驱动通知后，Server进程从线程池中取出线程，进行数据解包与调用目标方法。 将最终执行结果写入到自己的共享内存中。 Server进程将目标方法的结果返回给Client进程。 将最宠执行结果写入映射的用户空间的内存区域中。 由于内核缓存区与接收进程的用户空间地址存在映射关系(同时映射Binder创建的接收缓存区中)，相当于也发送到了内核缓存区中。 Binder通知Client进程获得返回结果(此时Client进程之前被挂起的线程被重新唤醒)。 Client进程通过系统调用copy_to_user()从内核缓存区接收Server 进程返回的结果。 优点： 传输效率高，每次单项通信数据拷贝次数一次，用户空间与内核空间可直接通过共享对象直交互。 为接收进程分配了不确定大小的接收缓存区。 额外说明 Client、Server、ServiceManager进程之间的交互都必须通过Binder驱动，并非直接交互。 Client、Server、ServiceManager进程数据进程空间的用户空间，不可直接交互。 Binder驱动属于进程空间的内核空间。 Binder驱动与ServiceManager属于Android基础架构( 系统已经实现)，而Client进程和Server进程应用层，需开发者自己实现。 Binder请求的线程管理 Server进程可能会创建多个线程来处理Binder请求。 Binder模型线程管理采用Binder驱动的线程池，并由Binder驱动自身管理，非Server进程管理。 一个进程Binder线程数默认为16。 Binder机制在Android具体实现原理 Binder机制在Android中实现主要靠Binder类，其实现了IBinder接口。 注册服务 Server进程通过Binder驱动像ServiceManager进程注册服务。 Server进程创建一个Binder对象。 Binder实体是Server进程在Binder驱动中的存在形式。 Binder实体保存Server和ServiceManager的信息(保存在内核空间中)。 Binder驱动通过内核空间的Binder实体找到用户空间的Server对象。 注册服务后，Binder驱动持有Server进程创建的BInder实体。 获取服务 Client进程使用某个service前，须通过Binder驱动向ServiceManager进程获取相应的Service信息。 使用服务Client 进程获取到的Service信息(Binder代理对象)，通过Binder驱动建立与该Server所在Server进程通信的链路，并开始使用服务。 优点Linux上的其他进程通信方式(管道、消息队列、共享内存、信号量、Socker)，Binder机制的优点： 高效 Binder机制拷贝只需一次，而管道、消息队列、Socket都需两次。 通过驱动在内核空间拷贝数据，不需要额外的同步处理。 安全性高 Binder机制为每个进程分配了UUID/PID来作为鉴别身份的表示。 在Binder通信时会根据UUID/PID进行有效性检测。 传统的进程通信方式对于通信双方的身份没有做出严格的验证。 使用简单 采用Client/Server架构 实现面向对象的调用方式(即在使用BInder时，就和调用一个本地对象实例一样)","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"https://batuer.github.io/tags/Binder/"}]},{"title":"Android性能优化","slug":"Android性能优化","date":"2018-04-24T00:24:40.007Z","updated":"2018-04-24T01:19:48.695Z","comments":true,"path":"2018/04/24/Android性能优化/","link":"","permalink":"https://batuer.github.io/2018/04/24/Android性能优化/","excerpt":"","text":"性能优化 流畅(卡顿优化) 内存优化 耗电优化 安装包大小优化 卡顿优化 原因 绘制任务太重，绘制一帧内容耗时太长。 主线程太忙，根据系统传递过来的 VSYNC 信号来时还没准备好数据导致丢帧。 优化 界面绘制卡顿 布局优化：布局嵌套过深、使用合适布局。列表控件缓存复用、include、merge、ViewStub、移除Activity默认背景。 数据处理阻塞UI线程。 获取数去耗时，占用UI线程。 处理数据占用CPU高，UI线程拿不到时间片。 内存占用过大 具体见内存优化。 启动优化 绘制优化。 启动加载逻辑优化。 可延迟初始化项，延迟初始化。 动画优化 可以使用硬件加速，提高流畅度。 工具 System Trace（收集和检测时间信息，CPU的消耗） Hierarchy Viewer（布局层级、绘制） TraceView（定位代码的执行时间） AndroidStudio3.0 自带的 Profiler 内存优化内存优化主要就是消除应用中的内存泄漏、避免内存抖动。 Android应用的沙箱机制，每个应用所分配的大小是有限度的，内存太低会被系统清除，即会出现闪退现象。搞懂Android内存管理机制，如何分配和回收的。 Android应用都是在Android虚拟机上运行，应用后才能徐的内存分配与垃圾回收都是由虚拟机完成的，因此不需要在代码中分配和释放内存。 Android内存分配回收机制 Anroid基于进程中运行的组件及其状态规定了默认的五个回收优先级：Empty process(空进程) &gt; Background process(后台进程) &gt; Service process(服务进程) &gt; Visible process(可见进程) &gt; Foreground process(前台进程)。 Android中由ActivityManagerService 集中管理所有进程的内存资源分配。 Android Dalvik Heap与原生Java一样，将堆的内存空间分为三个区域，Young Generation，Old Generation， Permanent Generation。最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。系统会根据内存中不同的内存数据类型分别执行不同的gc操作。GC发生的时候，所有的线程都是会被暂停的。执行GC所占用的时间和它发生在哪一个Generation也有关系，Young Generation中的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。 内存常见问题及解决 内存泄漏 单例（主要原因还是因为一般情况下单例都是全局的，有时候会引用一些实际生命周期比较短的变量，导致其无法释放） 静态变量（同样也是因为生命周期比较长） Handler内存泄露[ 匿名内部类（匿名内部类会引用外部类，导致无法释放，比如各种回调） 资源使用完未关闭（BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap） 内存泄漏检测LeakCanary，监控每个Activity，在activity ondestory后，在后台线程检测引用，然后过一段时间进行gc，gc后如果引用还在，那么dump出内存堆栈，并解析进行可视化显示。 资源性对象未关闭。比如Cursor、File文件等，往往都用了一些缓冲，在不使用时，应该及时关闭它们。 注册对象未注销。比如事件注册后未注销，会导致观察者列表中维持着对象的引用。 WebView。WebView 存在着内存泄漏的问题，在应用中只要使用一次 WebView，内存就不会被释放掉。 图片分辨率相关 很多情况下图片所占的内存在整个App内存占用中会占大部分。适配不同屏幕的图片资源。 优先考虑率使用webp格式图片代替传统格式图片。 图片压缩 BitmapFactory 在解码图片时，可以带一个Options参数，适当配置该参数。 缓存池大小 图片加载组件都不仅仅是使用软引用或者弱引用了，实际上类似Glide 默认使用的事LruCache，因为软引用 弱引用都比较难以控制，使用LruCache可以实现比较精细的控制，而默认缓存池设置太大了会导致浪费内存，设置小了又会导致图片经常被回收，所以需要根据每个App的情况，以及设备的分辨率，内存计算出一个比较合理的初始值，可以参考Glide的做法。 内存抖动 内存抖动引起OOM。大量小的对象频繁创建，导致内存碎片，从而当需要分配内存时，虽然总体上还是有剩余内存可分配，而由于这些内存不连续，导致无法分配，系统直接就返回OOM了。 常用数据结构优化 ArrayMap及SparseArray是android的系统API，是专门为移动设备而定制的。用于在一定情况下取代HashMap而达到节省内存的目的,具体性能见HashMap，ArrayMap，SparseArray源码分析及性能对比，对于key为int的HashMap尽量使用SparceArray替代，大概可以省30%的内存，而对于其他类型，ArrayMap对内存的节省实际并不明显，10%左右，但是数据量在1000以上时，查找速度可能会变慢。 枚举 Android平台上枚举是比较争议的，在较早的Android版本，使用枚举会导致包过大，在个例子里面，使用枚举甚至比直接使用int包的size大了10多倍 ，使用枚举需要谨慎，因为枚举变量可能比直接用int多使用2倍的内存。 尽量使用系统资源。 减少view的层级。 数据相关 使用protobuf。 dex优化，代码优化，谨慎使用外部库。 常用工具 Memory Analyzer(MAT)工具。MAT使用教程)，MAT - Memory Analyzer Tool 使用进阶)。 内存泄漏检测 Leakcanary。 AndroidStudio3.0 自带的 Profiler。 Android Lint 工具。 耗电优化Android5.0 以前，在应用中测试电量消耗比较麻烦，也不准确，5.0 之后专门引入了一个获取设备上电量消耗信息的 API:Battery Historian。Battery Historian 是一款由 Google 提供的 Android 系统电量分析工具，和Systrace 一样，是一款图形化数据分析工具，直观地展示出手机的电量消耗过程，通过输入电量分析文件，显示消耗情况，最后提供一些可供参考电量优化的方法。 常用方案： 计算优化，避开浮点运算等。 避免 WaleLock 使用不当。 使用 Job Scheduler。 安装包大小优化应用安装包大小对应用使用没有影响，但应用的安装包越大，用户下载的门槛越高，特别是在移动网络情况下，用户在下载应用时，对安装包大小的要求更高，因此，减小安装包大小可以让更多用户愿意下载和体验产品。常用方案： 代码混淆。使用proGuard 代码混淆器工具，它包括压缩、优化、混淆等功能。 资源优化。比如使用 Android Lint 删除冗余资源，资源文件最少化等。 图片优化。比如利用 AAPT 工具对 PNG 格式的图片做压缩处理，降低图片色彩位数等。 避免重复功能的库，使用 WebP图片格式等。 插件化。比如功能模块放在服务器上，按需下载，可以减少安装包大小。","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"性能优化","slug":"性能优化","permalink":"https://batuer.github.io/tags/性能优化/"}]},{"title":"Java内存","slug":"Java内存模型","date":"2018-04-13T00:31:06.347Z","updated":"2018-04-19T01:20:25.068Z","comments":true,"path":"2018/04/13/Java内存模型/","link":"","permalink":"https://batuer.github.io/2018/04/13/Java内存模型/","excerpt":"","text":"Java内存区域 程序计数器： 较小的内存空间。 当前线程锁执行的字节码行号指示器。 下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程回复等基本功能都依赖于计数器。 虚拟机栈： 线程私有，生命周期与线程相同。 每个方法执行的时候都会同时创建一个栈帧用于存储局部变量表、操作站、动态链接、方法出口等信息。 每个方法调用到执行完成，就想对应着一个栈帧在虚拟机中从入栈到出栈的过程。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError。 如果虚拟机栈扩展无法申请足够内存时会抛出OutOfMemoryError。 本地方法栈： 与虚拟机栈作用相似。 区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为Native方法服务。 堆： Java虚拟机中所管理内存中最大的一块。 所有线程共享，虚拟机启动时创建。 存放对象实例。 Java堆有划分成好几个区域。 内存不够时会抛出OutOfMemoryError。 方法区： 线程共享。 包含所有class和static变量。 运行时常量池都分配在Java虚拟机的方法区之中。 Java内存模型(Java Memory Model,JMM) 一种抽象概念，并不真实存在，描述的是一组规范。定义程序中各个变量的访问方式。 JMM可以屏蔽各种硬件和操作系统的访问差异，实现Java程序在各种平台下能达到一致的内存访问效果。 由于JVM(Java Virtual Machine)运行程序的实体是线程，每个线程创建时JVM都会为其创建一个栈空间，用于存储线程私有数据。 Java内存模型规定所有变量都存储于在主内存中，主内存是共享区域，线程对变量的操作必须在工作内存中进行。 主内存：所有线程创建的实例对象都存放在主内存中，不论是成员变量还是局部变量，由于是共享区域，所以涉及线程安全问题。 工作内存：存储当前方法的所有变量信息（主内存中的副本），线程间不可互相访问工作内存。 主内存的实例对象可以被多线程共享，拷贝副本到自己线程进行操作，执行操作完成刷新到主内存中。 JMM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见，这组规则也称为Java内存模型(即JMM)，JMM是围绕着程序执行的原子性。有序性、可见性展开的。 原子性：一个操作不可终端，即使在多线程环境下，一个操作不会受其他线程影响。 有序性(指令重排)：为了提高性能编译器和处理器常常会指令做重排。 编译器优化重排：重新安排语句的执行顺序并不严格按照代码顺序执行。 处理器重排：内存系统的重排，缓存的读写同步。 可见性：当某一线程修改了某个共享变量的值，其他线程能否马上得知这个修改的值。 JM们的解决方案： 基本数据类型读写操作具有原子性。 Synchronized关键字和重入锁(ReentrantLock)保证程序执行的原子性。 volatile关键字 精致重拍优化。 某一线程修改了volatile修饰的关键字，其他线程会马上得知修改值。 JMM中的happens-before原则： 程序顺序原则：一个线程内，代码顺序执行。 传递性。 锁规则：解锁操作必然在后续的同一个锁的加锁之前，有对应加锁解锁。 volatile规则：volatile修改前必然先读主内存。 线程启动规则：线程的start()方法先于它的每一个动作。 线程终端规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。 线程终止规则：线程的所有操作先于线程的终结。 对象终结规则：对象的构造函数执行，结束先于finalize()方法。 JMM就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before原则）及其外部可使用的同步手段(synchronized/volatile等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/tags/Java/"}]},{"title":"RxJava2操作符","slug":"RxJava2操作符","date":"2018-04-13T00:10:25.833Z","updated":"2018-04-13T00:10:25.833Z","comments":true,"path":"2018/04/13/RxJava2操作符/","link":"","permalink":"https://batuer.github.io/2018/04/13/RxJava2操作符/","excerpt":"","text":"创建基本创建 create() : 完整创建1个被观察者对象（Observable）快速创建 &amp; 发送事件 just() : 快速创建1个被观察者对象（Observable） 发送事件的特点：直接发送 传入的事件 最多只能创建10个 fromArray（）: 快速创建1个被观察者对象（Observable） 发送事件的特点：直接发送 传入的数组数据 10个以上事件 fromIterable（）: 快速创建一个被观察者对象(Observable) 发送事件的特点，直接发送传入的集合数据 发送10个以上事件延迟创建 defer(): 直到有观察者（Observer ）订阅时，才动态创建被观察者对象（Observable） &amp; 发送事件 timer(): 快速创建1个被观察者对象（Observable） 发送事件的特点：延迟指定时间后，发送1个数值0（Long类型） 本质:延迟执行onNext(0) interval(): 快速创建1个被观察者对象(Observable) 发送事件的特点:延迟初始化时间开始执行定时间隔发送事件 从0开始，递增1执行 intervalRange(): 快速创建1个被观察者对象(Observable) 发送事件的特点:类似于interval(),区别在于事件 起始值和数量有限制. range() /rangeLong() : 快速创建1个被观察者对象(Observable) 发送事件的特点: 连续发送事件，参数分别为起始值和事件数量.变换变换操作符 map(): 改变发射源的数据类型 flatMap(): 将被观察者发送的事件序列进行 拆分 &amp; 单独转换，再合并成一个新的事件序列，最后再进行发送(无序 ) 直接改变发射源 contactMap() : 类似于flatMap() 与FlatMap（）的 区别在于：拆分 &amp; 重新合并生成的事件序列 的顺序 = 被观察者旧序列生产的顺序(有序) switchMap() : switchMap的作用在flatMap的基础上，对输出结果若同时发生，只会保证最新结果而放弃旧数据。 buffer() : 定期从 被观察者（Observable）需要发送的事件中 获取一定数量的事件 &amp; 放到缓存区中，最终发送组合/合并组合多个被观察者 concat（） / concatArray（）: 组合多个被观察者一起发送数据，合并后 按发送顺序串行执行 二者区别：组合被观察者的数量，即concat（）组合被观察者数量≤4个，而concatArray（）则可＞4个 merge（） / mergeArray（）: 组合多个被观察者一起发送数据，合并后 按时间线并行执行 二者区别：组合被观察者的数量，即merge（）组合被观察者数量≤4个，而mergeArray（）则可＞4个 区别上述concat（）操作符：同样是组合多个被观察者一起发送数据，但concat（）操作符合并后是按发送顺序串行执行 concatDelayError（） / mergeDelayError（）: 使用contact或merge时，前面的某一事件发生error时终止其他观察者发送事件 用DelayError()推迟error事件至其它观察者发送完事件.合并多个事件 zip() 合并 多个被观察者（Observable）发送的事件，生成一个新的事件序列（即组合过后的事件序列），并最终发送 事件组合方式 = 严格按照原先事件序列 进行对位合并 被合并的事件都会执行完毕，最终合并的事件已最少的为基准。 combineLatest（） 当两个Observables中的任何一个发送了数据后，将先发送了数据的Observables 的最新（最后）一个数据 与 另外一个Observable发送的每个数据结合，最终基于该函数的结果发送数据 与Zip（）的区别：Zip（）= 按个数合并，即1对1合并；CombineLatest（） = 按时间合并，即在同一个时间点上合并 combineLatestDelayError() 类似于contactDelayError() reduce() 把被观察者需要发送的事件聚合成1个事件 &amp; 发送 聚合的逻辑根据需求撰写，但本质都是前2个数据聚合，然后与后1个数据继续进行聚合，依次类推 collect() 将被观察者Observable发送的数据事件收集到一个数据结构里发送事件前追加发送事件 startWitch()/startWithArray() 在一个被观察者发送事件前，追加发送一些数据 / 一个新的被观察者统计发送事件的数量 count() 统计被观察者发送的事件数量应用场景 &amp; 对应操作符详解连接被观察者 &amp; 观察者 subscribe（） 订阅，即连接观察者 &amp; 被观察者线程调度延迟操作 delay（） 使得被观察者延迟一段时间再发送事件在事件的生命周期中操作 do() 在某个事件的生命周期中调用 doOnEach 当Observable每发送1次数据事件就会调用1次.包含onNext、onError、onComplete doOnNext 执行Next事件前调用 doAfterNext 执行Next事件后调用 doOnComplete Observable正常发送事件完毕后调用 doOnError Observable发送错误事件时调用 doOnSubscribe 观察者订阅时调用 doAfterTerminate Observable发送事件完毕后调用，无论正常发送完毕 / 异常终止 doFinally 最后执行错误处理 onErrorReturn（） 遇到错误时，发送1个特殊事件 &amp; 正常终止 onErrorResumeNext（） 遇到错误时，发送1个新的Observable onErrorResumeNext（）拦截的错误 = Throwable；若需拦截Exception请用onExceptionResumeNext（） 若onErrorResumeNext（）拦截的错误 = Exception，则会将错误传递给观察者的onError方法 onExceptionResumeNext（） 遇到错误时，发送1个新的Observable onExceptionResumeNext（）拦截的错误 = Exception；若需拦截Throwable请用onErrorResumeNext（） 若onExceptionResumeNext（）拦截的错误 = Throwable，则会将错误传递给观察者的onError方法 retry() 重试，即当出现错误时，让被观察者（Observable）重新发射数据 接收到 onError（）时，重新订阅 &amp; 发送事件 Throwable 和 Exception都可拦截 retryUntil（） 出现错误后，判断是否需要重新发送数据 若需要重新发送 &amp; 持续遇到错误，则持续重试 作用类似于retry（Predicate predicate） 返回true则不重新发送数据事件 retryWhen（） 遇到错误时，将发生的错误传递给一个新的被观察者（Observable），并决定是否需要重新订阅原始被观察者（Observable）&amp; 发送事件 若返回的Observable发送的事件 = Next事件，则原始的Observable重新发送事件（若持续遇到错误，则持续重试） 返回的Observable发送的事件 = Error事件，则原始的Observable不重新发送事件,该异常错误信息可在观察者中的onError（）中获得重复发送 repeat() 无条件地、重复发送 被观察者事件 repeatWhen（） 有条件地、重复发送 被观察者事件 若新被观察者（Observable）返回1个Complete（） / Error（）事件，则不重新订阅 &amp; 发送原来的 Observable 若新被观察者（Observable）返回其余事件，则重新订阅 &amp; 发送原来的 Observable","categories":[{"name":"RxJava2","slug":"RxJava2","permalink":"https://batuer.github.io/categories/RxJava2/"}],"tags":[{"name":"RxJava2","slug":"RxJava2","permalink":"https://batuer.github.io/tags/RxJava2/"}]},{"title":"Java泛型","slug":"Java泛型","date":"2018-04-13T00:10:25.833Z","updated":"2018-04-13T00:10:25.833Z","comments":true,"path":"2018/04/13/Java泛型/","link":"","permalink":"https://batuer.github.io/2018/04/13/Java泛型/","excerpt":"","text":"一、泛型简介1.引入泛型的目的了解引入泛型的动机，就先从语法糖开始了解。 语法糖 语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。 泛型的目的： Java 泛型就是把一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现ClassCastException，即类型转换异常。 2.泛型初探JDK 1.5 时才增加了泛型，并在很大程度上都是方便集合的使用，使其能够记住其元素的数据类型。 3.泛型的好处①类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。 ②消除了代码中许多的强制类型转换，增强了代码的可读性。 ③为较大的优化带来了可能。 二、泛型的使用1.泛型类和泛型接口 这就是泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。 在JDK 1.7 增加了泛型的“菱形”语法：Java允许在构造器后不需要带完成的泛型信息，只要给出一对尖括号（&lt;&gt;）即可，Java可以推断尖括号里应该是什么泛型信息。 当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或者从该父类派生子类，需要注意：使用这些接口、父类派生子类时不能再包含类型形参，需要传入具体的类型。 2.泛型的方法 泛型类和泛型接口中提到，可以在泛型类、泛型接口的方法中，把泛型中声明的类型形参当成普通类型使用。 所谓泛型方法，就是在声明方法时定义一个或多个类型形参。 3.泛型构造器正如泛型方法允许在方法签名中声明类型形参一样，Java也允许在构造器签名中声明类型形参，这样就产生了所谓的泛型构造器。和使用普通泛型方法一样没区别，一种是显式指定泛型参数，另一种是隐式推断，如果是显式指定则以显式指定的类型参数为准，如果传入的参数的类型和指定的类型实参不符，将会编译报错。 三、类型通配符顾名思义就是匹配任意类型的类型实参。 类型通配符是一个问号（？)，将一个问号作为类型实参传给List集合，写作：List&lt;?&gt;（意思是元素类型未知的List）。这个问号（？）被成为通配符，它的元素类型可以匹配任何类型。 带限通配符简单来讲，使用通配符的目的是来限制泛型的类型参数的类型，使其满足某种条件，固定为某些类。 主要分为两类即：上限通配符和下限通配符。 1.上限通配符如果想限制使用泛型类别时，只能用某个特定类型或者是其子类型才能实例化该类型时，可以在定义类型时，使用extends关键字指定这个类型必须是继承某个类，或者实现某个接口，也可以是这个类或接口本身。 2.下限通配符如果想限制使用泛型类别时，只能用某个特定类型或者是其父类型才能实例化该类型时，可以在定义类型时，使用super关键字指定这个类型必须是是某个类的父类，或者是某个接口的父接口，也可以是这个类或接口本身。 四、类型擦除 不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://batuer.github.io/tags/Java基础/"},{"name":"Java泛型","slug":"Java泛型","permalink":"https://batuer.github.io/tags/Java泛型/"}]},{"title":"Java反射","slug":"JavaReflect","date":"2018-04-13T00:10:25.833Z","updated":"2018-04-13T00:10:25.833Z","comments":true,"path":"2018/04/13/JavaReflect/","link":"","permalink":"https://batuer.github.io/2018/04/13/JavaReflect/","excerpt":"","text":"一、概述Java反射机制定义 Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java 反射机制的功能 1.在运行时判断任意一个对象所属的类。 2.在运行时构造任意一个类的对象。 3.在运行时判断任意一个类所具有的成员变量和方法。 4.在运行时调用任意一个对象的方法。 5.生成动态代理。 Java 反射机制的应用场景 1.逆向代码 ，例如反编译 2.与注解相结合的框架 例如Retrofit 3.单纯的反射机制应用框架 例如EventBus 4.动态生成类框架 例如Gson 二、代理模式定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。 1、代理模式的参与者代理模式的角色分四种： 主题接口：Subject 是委托对象和代理对象都共同实现的接口，即代理类的所实现的行为接口。Request() 是委托对象和代理对象共同拥有的方法。目标对象：ReaSubject 是原对象，也就是被代理的对象。代理对象：Proxy 是代理对象，用来封装真是主题类的代理类。客户端 ：使用代理类和主题接口完成一些工作。 2、代理模式的分类代理的实现分为： 静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。 3、代理模式的实现思路1.代理对象和目标对象均实现同一个行为接口。 2.代理类和目标类分别具体实现接口逻辑。 3.在代理类的构造函数中实例化一个目标对象。 4.在代理类中调用目标对象的行为接口。 5.客户端想要调用目标对象的行为接口，只能通过代理类来操作。 4、静态代理模式的简单实现1234567891011121314151617181920212223242526272829303132public class ProxyDemo &#123; public static void main(String args[]) &#123; ShopCart subject = new ShopCart(); ShopProxy p = new ShopProxy(subject); p.shop(); &#125; &#125; interface Shop &#123; void shop(); &#125; class ShopCart implements Shop &#123; @Override public void shop() &#123; Log.w(\"Fire\", \"ShopCart:25: Shop\"); &#125; &#125; class ShopProxy implements Shop &#123; private ShopCart mShopCart; public ShopProxy(ShopCart shopCart) &#123; mShopCart = shopCart; &#125; @Override public void shop() &#123; Log.w(\"Fire\", \"ShopProxy:38:登录验证\"); mShopCart.shop(); Log.w(\"Fire\", \"ShopProxy:40:日志记录\"); &#125; &#125; 目标对象(RealSubject )以及代理对象（Proxy）都实现了主题接口（Subject）。在代理对象（Proxy）中，通过构造函数传入目标对象(RealSubject )，然后重写主题接口（Subject）的request()方法，在该方法中调用目标对象(RealSubject )的request()方法，并可以添加一些额外的处理工作在目标对象(RealSubject )的request()方法的前后。 代理模式的好处： 假如有这样的需求，要在某些模块方法调用前后加上一些统一的前后处理操作，比如在添加购物车、修改订单等操作前后统一加上登陆验证与日志记录处理，该怎样实现？首先想到最简单的就是直接修改源码，在对应模块的对应方法前后添加操作。如果模块很多，你会发现，修改源码不仅非常麻烦、难以维护，而且会使代码显得十分臃肿。 这时候就轮到代理模式上场了，它可以在被调用方法前后加上自己的操作，而不需要更改被调用类的源码，大大地降低了模块之间的耦合性，体现了极大的优势。 三、Java反射机制与动态代理1、动态代理介绍动态代理是指在运行时动态生成代理类。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。与静态处理类相比，动态类有诸多好处。 ①不需要为(RealSubject )写一个形式上完全一样的封装类，假如主题接口（Subject）中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则目标对象和代理类都要修改，不利于系统维护； ②使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。 2、动态代理涉及的主要类java.lang.reflect.Proxy:这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。Proxy提供了用户创建动态代理类和代理对象的静态方法，它是所有动态代理类的父类。 java.lang.reflect.InvocationHandler:这里称他为”调用处理器”，它是一个接口。当调用动态代理类中的方法时，将会直接转接到执行自定义的InvocationHandler中的invoke()方法。即我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口，通过重写invoke()方法来执行具体内容。 Proxy提供了如下两个方法来创建动态代理类和动态代理实例。 static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces) 返回代理类的java.lang.Class对象。第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么），该代理类将实现interfaces所指定的所有接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法。 static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 返回代理类实例。参数与上述方法一致。 对应上述两种方法创建动态代理对象的方式： 12345678//创建一个InvocationHandler对象InvocationHandler handler = new MyInvocationHandler(.args..);//使用Proxy生成一个动态代理类Class proxyClass = Proxy.getProxyClass(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces());//获取proxyClass类中一个带InvocationHandler参数的构造器Constructor constructor = proxyClass.getConstructor(InvocationHandler.class);//调用constructor的newInstance方法来创建动态实例RealSubject real = (RealSubject)constructor.newInstance(handler); 123456 //创建一个InvocationHandler对象InvocationHandler handler = new MyInvocationHandler();//使用Proxy直接生成一个动态代理对象RealSubject real = (RealSubject) java.lang.reflect.Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler); newProxyInstance这个方法实际上做了两件事：第一，创建了一个新的类【代理类】，这个类实现了Class[] interfaces中的所有接口，并通过你指定的ClassLoader将生成的类的字节码加载到JVM中，创建Class对象；第二，以你传入的InvocationHandler作为参数创建一个代理类的实例并返回。 Proxy 类还有一些静态方法，比如： InvocationHandler getInvocationHandler(Object proxy):获得代理对象对应的调用处理器对象。 Class getProxyClass(ClassLoader loader, Class[] interfaces):根据类加载器和实现的接口获得代理类。 InvocationHandler 接口中有方法： invoke(Object proxy, Method method, Object[] args)这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。 3、动态代理模式的简单实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * Created by Administrator on 2018/2/17. */public class DynamicProxyDemo &#123; public static void main(String[] args) &#123; //1.创建目标对象 RealSubject realSubject = new RealSubject(); //2.创建调用处理器对象 ProxyHandler handler = new ProxyHandler(realSubject); //3.动态生成代理对象 Subject proxySubject = (Subject) Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler); //4.通过代理对象调用方法 proxySubject.request(); &#125;&#125;/** * 主题接口 */interface Subject &#123; void request();&#125;/** * 目标对象类 */class RealSubject implements Subject &#123; public void request() &#123; System.out.println(\"====RealSubject Request====\"); &#125;&#125;/** * 代理类的调用处理器 */class ProxyHandler implements InvocationHandler &#123; private Subject subject; public ProxyHandler(Subject subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作 System.out.println(\"====before====\"); //调用RealSubject中的方法 Object result = method.invoke(subject, args); System.out.println(\"====after====\"); return result; &#125;&#125; 可以看到，我们通过newProxyInstance就产生了一个Subject 的实例，即代理类的实例，然后就可以通过Subject .request()，就会调用InvocationHandler中的invoke()方法，传入方法Method对象，以及调用方法的参数，通过Method.invoke调用RealSubject中的方法的request()方法。同时可以在InvocationHandler中的invoke()方法加入其他执行逻辑。 四、泛型和Class类从JDK 1.5 后，Java中引入泛型机制，Class类也增加了泛型功能，从而允许使用泛型来限制Class类，例如：String.class的类型实际上是Class&lt;String&gt;。如果Class对应的类暂时未知，则使用Class&lt;?&gt;(?是通配符)。通过反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。 泛型的好处众多，最主要的一点就是避免类型转换，防止出现ClassCastException，即类型转换异常。 五、使用反射来获取泛型信息通过指定类对应的 Class 对象，可以获得该类里包含的所有 Field，不管该 Field 是使用 private 修饰，还是使用 public 修饰。获得了 Field 对象后，就可以很容易地获得该 Field 的数据类型，即使用如下代码即可获得指定 Field 的类型。 12// 获取 Field 对象 f 的类型Class&lt;?&gt; a = f.getType(); 但这种方式只对普通类型的 Field 有效。如果该 Field 的类型是有泛型限制的类型，如 Map&lt;String, Integer&gt; 类型，则不能准确地得到该 Field 的泛型参数。 为了获得指定 Field 的泛型类型，应先使用如下方法来获取指定 Field 的类型。 12// 获得 Field 实例的泛型类型Type type = f.getGenericType(); 然后将 Type 对象强制类型转换为 ParameterizedType 对象，ParameterizedType 代表被参数化的类型，也就是增加了泛型限制的类型。ParameterizedType 类提供了如下两个方法。 getRawType()：返回没有泛型信息的原始类型。 getActualTypeArguments()：返回泛型参数的类型。 下面是一个获取泛型类型的完整程序。 123456789101112131415161718192021222324252627282930313233343536public class GenericTest&#123; private Map&lt;String , Integer&gt; score; public static void main(String[] args) throws Exception &#123; Class&lt;GenericTest&gt; clazz = GenericTest.class; Field f = clazz.getDeclaredField(\"score\"); // 直接使用getType()取出Field类型只对普通类型的Field有效 Class&lt;?&gt; a = f.getType(); // 下面将看到仅输出java.util.Map System.out.println(\"score的类型是:\" + a); // 获得Field实例f的泛型类型 Type gType = f.getGenericType(); // 如果gType类型是ParameterizedType对象 if(gType instanceof ParameterizedType) &#123; // 强制类型转换 ParameterizedType pType = (ParameterizedType)gType; // 获取原始类型 Type rType = pType.getRawType(); System.out.println(\"原始类型是：\" + rType); // 取得泛型类型的泛型参数 Type[] tArgs = pType.getActualTypeArguments(); System.out.println(\"泛型类型是:\"); for (int i = 0; i &lt; tArgs.length; i++) &#123; System.out.println(\"第\" + i + \"个泛型类型是：\" + tArgs[i]); &#125; &#125; else &#123; System.out.println(\"获取泛型类型出错！\"); &#125; &#125;&#125; 输出结果： score 的类型是: interface java.util.Map原始类型是: interface java.util.Map泛型类型是:第 0 个泛型类型是: class java.lang.String第 1 个泛型类型是：class java.lang.Integer 从上面的运行结果可以看出，直接使用 Field 的 getType() 方法只能获取普通类型的 Field 的数据类型：对于增加了泛型参数的类型的 Field，应该使用 getGenericType() 方法来取得其类型。 Type 也是 java.lang.reflect 包下的一个接口，该接口代表所有类型的公共高级接口，Class 是 Type 接口的实现类。Type 包括原始类型、参数化类型、数组类型、类型变量和基本类型等。","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://batuer.github.io/tags/Java基础/"},{"name":"Java反射","slug":"Java反射","permalink":"https://batuer.github.io/tags/Java反射/"}]},{"title":"Android多进程","slug":"MultiProcess","date":"2018-04-13T00:10:25.833Z","updated":"2018-04-13T00:28:14.822Z","comments":true,"path":"2018/04/13/MultiProcess/","link":"","permalink":"https://batuer.github.io/2018/04/13/MultiProcess/","excerpt":"","text":"多进程概念多进程就是多个进程。一个应用程序默认只有一个进程，这个进程的名称就是报名。 进程是系统资源个分配的基本单位，线程死调度的基本单位。 每个进程都有自己独立的资源和内存空间。 其它进程不可随意访问其它进程的内存和资源。 系统给每个进程分配的内存有限制。 多进程的创建四大组件在AndroidManifset文件中注册的时候，有个属性android:process这里可以指定组件多出的进程。默认主进程。android:process=”:deamon”以:开头的名字位私有进程，否则全局进程。 多进程的优缺点 好处 分担主进程内存压力，将一些独立的组件放到不同的进程中，它就不占用主进程的内存空间，如大图片或多图片的组件或WebView。 帮助应用常驻后台，防止主进程被杀守护进程，主进程与守护进程相互监视唤醒。 坏处 消耗用电 多占用系统空间 必要时需要处理多进程间通信。 多进程的缺陷 Application多次重建 获取进程id获取进程名称，处理相应进程的业务 静态成员失效 使用Intent或aidl等进程通信方式传递内容，不能使用静态或单例模式。 文件共享问题 多进程并发操作数据库，难以通过锁机制控制，考虑都使用主进程进行数据库操作(ContentProvider)。 断点调试问题 调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试。因此要改为同一进程：调试时去掉AndroidManifest.xml中android:process标签，这样保证调试状态下是在同一进程中，堆栈信息是连贯的。待调试完成后，再将标签复原。 多进程间通信IPC 通过Intent/Bundle传递数据 通过文件缓存，一个进程写另一个进程读取 通过ContentProvider提供入口，共享数据 通过Socket方式，系统中的进程服务也有如此方式 通过AIDL实现进程通信，可以做到多端连接，异步通信，避免阻塞 Messenger 利用Handler实现，适用于多进程、单线程、不需要考虑线程安全。底层基于AIDL实现。 通过广播","categories":[{"name":"多进程","slug":"多进程","permalink":"https://batuer.github.io/categories/多进程/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"多进程","slug":"多进程","permalink":"https://batuer.github.io/tags/多进程/"}]},{"title":"Java注解","slug":"JavaAnnotaion","date":"2018-04-13T00:10:25.832Z","updated":"2018-04-13T00:10:25.832Z","comments":true,"path":"2018/04/13/JavaAnnotaion/","link":"","permalink":"https://batuer.github.io/2018/04/13/JavaAnnotaion/","excerpt":"","text":"一、元数据 https://gitee.com/pianzhi110/Fragmentation/tree/master/app/src/main/java/com/gusi/fragmentation/annotation 要想理解注解（Annotation）的作用，就要先理解Java中元数据的概念。 1.元数据概念元数据是关于数据的数据。在编程语言上下文中，元数据是添加到程序元素如方法、字段、类和包上的额外信息。对数据进行说明描述的数据。 2.元数据的作用一般来说，元数据可以用于创建文档（根据程序元素上的注释创建文档），跟踪代码中的依赖性（可声明方法是重载，依赖父类的方法），执行编译时检查（可声明是否编译期检测），代码分析。如下：1） 编写文档：通过代码里标识的元数据生成文档 2）代码分析：通过代码里标识的元数据对代码进行分析 3）编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查 3.Java平台元数据注解Annotation就是java平台的元数据，是 J2SE5.0新增加的功能，该机制允许在Java 代码中添加自定义注释，并允许通过反射（reflection），以编程方式访问元数据注释。通过提供为程序元素（类、方法等）附加额外数据的标准方法，元数据功能具有简化和改进许多应用程序开发领域的潜在能力，其中包括配置管理、框架实现和代码生成。 二、注解（Annotation）1.注解（Annotation）的概念注解(Annotation)在JDK1.5之后增加的一个新特性，注解的引入意义很大，有很多非常有名的框架，比如Hibernate、Spring等框架中都大量使用注解。注解作为程序的元数据嵌入到程序。注解可以被解析工具或编译工具解析。 关于注解（Annotation）的作用，其实就是上述元数据的作用。 注意：Annotation能被用来为程序元素（类、方法、成员变量等）设置元素据。Annotaion不影响程序代码的执行，无论增加、删除Annotation，代码都始终如一地执行。如果希望让程序中的Annotation起一定的作用，只有通过解析工具或编译工具对Annotation中的信息进行解析和处理。 2.内建注解Java提供了多种内建的注解，下面接下几个比较常用的注解：@Override、@Deprecated、@SuppressWarnings以及@FunctionalInterface这4个注解。内建注解主要实现了元数据的第二个作用：编译检查。 @Override用途：用于告知编译器，我们需要覆写超类的当前方法。如果某个方法带有该注解但并没有覆写超类相应的方法，则编译器会生成一条错误信息。如果父类没有这个要覆写的方法，则编译器也会生成一条错误信息。 @Override可适用元素为方法，仅仅保留在java源文件中。 @Deprecated用途：使用这个注解，用于告知编译器，某一程序元素(比如方法，成员变量)不建议使用了（即过时了）。 @SuppressWarnings用途：用于告知编译器忽略特定的警告信息，例在泛型中使用原生数据类型，编译器会发出警告，当使用该注解后，则不会发出警告。 注解类型分析： @SuppressWarnings可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。 该注解有方法value(）,可支持多个字符串参数，用户指定忽略哪种警告。 3.元AnnotationJDK除了在java.lang提供了上述内建注解外，还在java.lang。annotation包下提供了6个Meta Annotation(元Annotataion)，其中有5个元Annotation都用于修饰其他的Annotation定义。其中@Repeatable专门用户定义Java 8 新增的可重复注解。 我们先介绍其中4个常用的修饰其他Annotation的元Annotation。在此之前，我们先了解如何自定义Annotation。 当一个接口直接继承java.lang.annotation.Annotation接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过@interface关键字的方式，其实通过该方式会隐含地继承.Annotation接口。 @Documented @Documented用户指定被该元Annotation修饰的Annotation类将会被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。 @Inherited(世袭) 默认情况下,我们自定义的注解用在父类上不会被子类所继承.如果想让子类也继承父类的注解,即注解在子类也生效,需要在自定义注解时设置@Inherited.一般情况下该注解用的比较少. @Retention @Retention：表示该注解类型的注解保留的时长。当注解类型声明中没有@Retention元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留策略，如下表： @Target @Target：表示该注解类型的所适用的程序元素类型。当注解类型声明中没有@Target元注解，则默认为可适用所有的程序元素。如果存在指定的@Target元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素，如下表： 三、自定义注解（Annotation）创建自定义注解，与创建接口有几分相似，但注解需要以@开头。 其定义是以无形参的方法形式来声明的。 此处只能使用public或者默认的default两个权限修饰符。 配置参数的类型只能使用基本类型(byte,boolean,char,short,int,long,float,double)和String,Enum,Class,annotation。 配置参数一旦设置,其参数值必须有确定的值,要不在使用注解的时候指定,要不在定义注解的时候使用default为其设置默认值,对于非基本类型的参数值来说,其不能为null。 当然注解中也可以不存在成员变量，在使用解析注解进行操作时，仅以是否包含该注解来进行操作。当注解中有成员变量时，若没有默认值，需要在使用注解时，指定成员变量的值。 四、注解解析接下来，通过反射技术来解析自定义注解。关于反射类位于包java.lang.reflect，其中有一个接口AnnotatedElement，该接口主要有如下几个实现类：Class，Constructor，Field，Method，Package。除此之外，该接口定义了注释相关的几个核心方法，如下：因此，当获取了某个类的Class对象，然后获取其Field,Method等对象，通过上述4个方法提取其中的注解，然后获得注解的详细信息。","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://batuer.github.io/tags/Java基础/"},{"name":"Java注解","slug":"Java注解","permalink":"https://batuer.github.io/tags/Java注解/"}]},{"title":"Java集合","slug":"JavaBasic","date":"2018-04-13T00:10:25.832Z","updated":"2018-04-13T00:10:25.832Z","comments":true,"path":"2018/04/13/JavaBasic/","link":"","permalink":"https://batuer.github.io/2018/04/13/JavaBasic/","excerpt":"","text":"一、Java集合类简介：Java集合大致可以分为Set、List、Queue和Map四种体系。 其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。Java 5 又增加了Queue体系集合，代表一种队列集合实现。 Java集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。从Java 5 增加了泛型以后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。 1.Java集合和数组的区别：①.数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。 ②.数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上只是保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。 2.Java集合类之间的继承关系:Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。 图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。 Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。 图中，HashMap，TreeMap是我们经常会用到的集合类。 二、Collection接口：1.简介Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。由于方法比较多，就偷个懒，直接把JDK文档上的内容搬过来。 1.1.接口中定义的方法 可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。其中重点介绍iterator()方法，该方法的返回值是Iterator。 1.2.使用Iterator遍历集合元素Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。Iterator接口中主要定义了2个方法： 下面程序简单示范了通过Iterator对象逐个获取元素的逻辑。123456789101112131415161718public class IteratorExample &#123; public static void main(String[] args)&#123; //创建集合，添加元素 Collection&lt;Day&gt; days = new ArrayList&lt;Day&gt;(); for(int i =0;i&lt;10;i++)&#123; Day day = new Day(i,i*60,i*3600); days.add(day); &#125; //获取days集合的迭代器 Iterator&lt;Day&gt; iterator = days.iterator(); while(iterator.hasNext())&#123;//判断是否有下一个元素 Day next = iterator.next();//取出该元素 //逐个遍历，取得元素后进行后续操作 ..... &#125; &#125;&#125; 注意： 当使用Iterator对集合元素进行迭代时，把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量。下面的程序演示了这一点：123456789101112131415161718192021222324252627282930public class IteratorExample &#123; public static void main(String[] args) &#123; List&lt;MyObject&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; list.add(new MyObject(i)); &#125; System.out.println(list.toString()); Iterator&lt;MyObject&gt; iterator = list.iterator();//集合元素的值传给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址 while (iterator.hasNext()) &#123; MyObject next = iterator.next(); next.num = 99; &#125; System.out.println(list.toString()); &#125; static class MyObject &#123; int num; MyObject(int num) &#123; this.num = num; &#125; @Override public String toString() &#123; return String.valueOf(num); &#125; &#125;&#125; 输出结果如下： [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [99, 99, 99, 99, 99, 99, 99, 99, 99, 99] 下面具体介绍Collection接口的三个子接口Set，List，Queue。 2.Set集合简介Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。 Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。 3.List集合3.1.简介List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为0，第二个添加的元素索引为1…… List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。 3.2.接口中定义的方法 void add(int index, Object element): 在列表的指定位置插入指定元素（可选操作）。 boolean addAll(int index, Collection&lt;? extends E&gt; c) : 将集合c 中的所有元素都插入到列表中的指定位置index处。 Object get(index): 返回列表中指定位置的元素。 int indexOf(Object o): 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 int lastIndexOf(Object o): 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 Object remove(int index): 移除列表中指定位置的元素。 Object set(int index, Object element): 用指定元素替换列表中指定位置的元素。 List subList(int fromIndex, int toIndex): 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的所有集合元素组成的子集。 Object[] toArray(): 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。 除此之外，Java 8还为List接口添加了如下两个默认方法。 void replaceAll(UnaryOperator operator): 根据operator指定的计算规则重新设置List集合的所有元素。 void sort(Comparator c): 根据Comparator参数对List集合的元素排序。 4.Queue集合4.1.简介Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。 4.2.接口中定义的方法 三、Map集合1.简介Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。 如下图所描述，key和value之间存在单向一对一关系，即通过指定的key,总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value。 2.Map集合与Set集合、List集合的关系①.与Set集合的关系 如果 把Map里的所有key放在一起看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个keySet()方法，用户返回Map里所有key组成的Set集合。 ②.与List集合的关系 如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。 3.接口中定义的方法 Map中还包括一个内部类Entry，该类封装了一个key-value对。Entry包含如下三个方法： Map集合最典型的用法就是成对地添加、删除key-value对，然后就是判断该Map中是否包含指定key，是否包含指定value，也可以通过Map提供的keySet()方法获取所有key组成的集合，然后使用foreach循环来遍历Map的所有key，根据key即可遍历所有的value。下面程序代码示范Map的一些基本功能： 1234567891011121314151617181920212223242526public class MapTest &#123; public static void main(String[] args)&#123; Day day1 = new Day(1, 2, 3); Day day2 = new Day(2, 3, 4); Map&lt;String,Day&gt; map = new HashMap&lt;String,Day&gt;(); //成对放入key-value对 map.put(\"第一个\", day1); map.put(\"第二个\", day2); //判断是否包含指定的key System.out.println(map.containsKey(\"第一个\")); //判断是否包含指定的value System.out.println(map.containsValue(day1)); //循环遍历 //1.获得Map中所有key组成的set集合 Set&lt;String&gt; keySet = map.keySet(); //2.使用foreach进行遍历 for (String key : keySet) &#123; //根据key获得指定的value System.out.println(map.get(key)); &#125; //根据key来移除key-value对 map.remove(\"第一个\"); System.out.println(map); &#125;&#125; 输出结果： true true Day [hour=2, minute=3, second=4] Day [hour=1, minute=2, second=3] {第二个=Day [hour=2, minute=3, second=4]} 四、e.g. 123456数组: 优点：使用方便 ，查询效率 比链表高，内存为一连续的区域 缺点：大小固定，不适合动态存储，不方便动态添加链表： 优点：可动态添加删除 大小可变 缺点：只能通过顺次指针访问，查询效率低 ArrayList: 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。 按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。 直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。 ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。 LinkedList: 以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。 按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。 插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add()，addFirst()，removeLast()或用iterator()上的remove()能省掉指针的移动。 LinkedList是一个简单的数据结构，与ArrayList不同的是，他是基于链表实现的。 set和get函数都调用了node函数，该函数会以O(n/2)的性能去获取一个节点。 判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n/2)。 HashMap:1. 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，不保证有序(比如插入的顺序)、也不保证序不随时间变。HashMap存储着Entry(hash, key, value, next)对象。 2. 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( (n-1) &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。 4. 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。 TreeMap: HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。 LinkedHashMap: LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。 保证双向链表中的节点次序或者双向链表容量所 总之，LinkedHashMap不愧是HashMap的儿子，和老子太像了，当然，青出于蓝而胜于蓝，LinkedHashMap的其他的操作也基本上都是为了维护好那个具有访问顺序的双向链表。 ArrayMap: ArrayMap的存储中没有Entry这个东西，他是由两个数组来维护的，mHashes数组中保存的是每一项的HashCode值，mArray中就是键值对，每两个元素代表一个键值对，前面保存key，后面的保存value。 HashMap内部有一个HashMapEntry[]对象，每一个键值对都存储在这个对象里，当使用put方法添加键值对时，就会new一个HashMapEntry对象，而ArrayMap的存储中没有Entry这个东西，他是由两个数组来维护的，mHashes数组中保存的是每一项的HashCode值，mArray中就是键值对，每两个元素代表一个键值对，前面保存key，后面的保存value。 ArrayMap 和 HashMap区别： 存储方式不同： HashMap内部有一个HashMapEntry[]对象，每一个键值对都存储在这个对象里，当使用put方法添加键值对时，就会new一个HashMapEntry对象。 ArrayMap的存储中没有Entry这个东西，他是由两个数组来维护的mHashes数组中保存的是每一项的HashCode值，mArray中就是键值对，每两个元素代表一个键值对，前面保存key，后面的保存value。 添加数据时扩容时的处理不一样： HashMap使用New的方式申请空间，并返回一个新的对象，开销会比较大。 ArrayMap用的是System.arrayCopy数据，所以效率相对要高。 ArrayMap提供了数组收缩的功能，只要判断过判断容量尺寸，例如clear，put，remove等方法，只要通过判断size大小触发到freeArrays或者allocArrays方法，会重新收缩数组，释放空间。 ArrayMap相比传统的HashMap速度要慢，因为查找方法是二分法，并且当你删除或者添加数据时，会对空间重新调整，在使用大量数据时，效率低于50%。可以说ArrayMap是牺牲了时间换区空间。但在写手机app时，适时的使用ArrayMap，会给内存使用带来可观的提升。ArrayMap内部还是按照正序排列的，这时因为ArrayMap在检索数据的时候使用的是二分查找，所以每次插入新数据的时候ArrayMap都需要重新排序，逆序是最差情况；","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://batuer.github.io/tags/Java基础/"},{"name":"Java集合","slug":"Java集合","permalink":"https://batuer.github.io/tags/Java集合/"}]},{"title":"Android面试","slug":"Interview","date":"2018-04-13T00:10:25.832Z","updated":"2018-04-13T00:27:44.667Z","comments":true,"path":"2018/04/13/Interview/","link":"","permalink":"https://batuer.github.io/2018/04/13/Interview/","excerpt":"","text":"一、JavaJava基础 对封装、抽象、继承、多态的理解 封装：面向对象重要原则，把过程和数据包围起来，数据的访问通过自定义接口，隐藏内部实现细节。增加安全性。 抽象：同一事物共有属性和方法的集合，多态的基础。 继承：代码复用的重要手段。单继承特点，只有一个父类，继承父类非私有属性和方法。根据自身需求扩展。 多态：同一种行为具有不同的表现形态或形式的能力。程序中定义的引用变量在编译时期不能确定具体类型，在运行中才能知道具体类型。 泛型的作用及使用场景 作用：编译阶段完成类型转换，避免运行时期转换异常。类型安全。 场景： 泛型类和接口 泛型方法 泛型构造器 类型通配符，上限和下限通配符。 枚举的特点及使用场景 特点： 枚举的直接父类是java.lang.Enum，但是不能显示的继承Enum。 枚举就相当于一个类，可以定义构造方法、成员变量、普通方法和抽象方法。 每个实例分别用于一个全局常量表示，枚举类型的对象是固定的，实例个数有限，不能使用new关键字。 枚举实例后有花括号时，该实例是枚举的匿名内部类对象。 场景： 普通常量。 枚举中添加变量、构造函数，灵活获取指定值。 添加自己特定的方法，实现自己的需求。根据code获取相应的对应值。（常见于原因Code获取具体原因描述） 线程sleep和wait的区别 sleep（）属于Thread，wait（）属于Object.。 sleep（）仅仅是睡眠，不涉及到锁的释放问题，让出CPU，睡眠时间结束自动竞争CPU执行。 wait（）绑定了某个对象的锁，等待该对象的notify（），notifyAll（）来唤醒自己，等待的时间是未知的，甚至出现死锁。 无论怎用sleep都会释放cpu，但是在线程池中会占用位置。（CPU和线程区别）。 JAVA反射机制 Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 生成动态代理。 weak/soft/strong引用的区别 JAVA虚拟机通过可达性（Reachability)来判断对象是否存活，基本思想：以”GC Roots”的对象作为起始点向下搜索，搜索形成的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（即不可达的），则该对象被判定为可以被回收的对象，反之不能被回收。 Strong：普通的java引用，我们通常new的对象就是： StringBuffer buffer = new StringBuffer(); 如果一个对象通过一串强引用链可达，那么它就不会被垃圾回收。 Soft：当内存不足的时候才回收它。 Weak：一旦gc发现对象是weakReference可达，就会把它放到ReferenceQueue中，下次gc时回收它。 Phantom：和soft，weak Reference区别较大，它的get()方法总是返回null。 Object的hashCode()与equals()的区别和作用 equals() 的作用是 用来判断两个对象是否相等。 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode是为了提高在散列结构存储中查找的效率，在线性表中没有作用。 interface和abstract class区别 Java抽象类定义的两种机制，这两张机制赋予了Java强大的面向对象能力。两者有很大相似性，也可以相互替换，但两者之间也有很大区别。 抽象类：在代码中使用abstract修饰的class即为抽象类，类对象的抽象集合。具体的使用中主要用来进行类型隐藏，我们可以构造出一组固定的行为，这组行为却能够有任意个可能的具体实现，这个抽象描述就是抽象类，这一组任意个可能的具体实现则表现为泽类。这样模块可以操作一个抽象提，由于模块依赖于一个固定的抽象提，一次它可以使不允许修改的，但是允许扩展，这就是面向对象设计的一个核心原则OCP，抽象是关键所在。 接口：比abstract class更加抽象，是一种特殊的abstract class。用Interface关键字修饰，类方法的抽象集合。为了把程序模块进行固话契约，降低耦合。 集合类 JAVA常用集合类功能、区别和性能 Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。 ​ 图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。 Collection: 最基本的集合类型，实现Iterable接口。 List: 有序，可重复。 LinkedList: 双向链表实现，可被用作堆栈、队列、双向队列，set和get函数以O(n/2)的性能获取一个节点。 ArrayList: 数组实现，自动扩容。 Vector: 数组实现，自动扩容，同步存取。 Stack: 继承Vector,实现后进先出堆栈，提供5个额外方法使得Vector当堆栈使用。 Set: 不可重复。 HashSet: 代用对象hashCode，计算存放位置,通过hashCode 和equals判断重复。(HashMap的Key的判断,无序) TreeSet: 排序。(TreeMap存取) Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。 图中，HashMap和TreeMap经常用到。 Map: Key和Value 的映射，不包含相同的Key。 HashTable: 同步，存取非空对象。(Entrty对象) HashMap: 不同步，允许空对象，不保证有序，存储Entrty。 Treemap: 类似HashMap，实现排序。 LinkedHashMap: Hash表和链表的实现，类似HashMap，保证双向链表节点的顺序。 WeakHashMap: key弱应用。 ArrayMap: 没用Entrty，由两数组维护。速度慢于HashMap，有排序，二分法查找，数组收缩功能，时间换空间。 并发相关的集合类 Vector Synchronize实现 数组保证顺序 自动扩容，System.arraycopy()效率低 适合一次赋值多次读取，数据量小的多线程环境 Stack Vector子类,扩展5个关于栈的操作方法 栈先进后出 HashTable Synchronize实现 Entrty对象 Concurrent包提供的线程安全集合 ConcurrentHashMap 不允许空键值对 使用ReentranLock保证线程安全 ConcurrentLinkedDeque 双端队列 Linked大小不受限 ConcurrentLinkedQueue ConcurrentSkipListMap ConcurrentSkipSet 基于ConcurrentSkipListMap实现 CopyOnWriteArrayList 写入时赋值数组 ReentrantLock实现线程安全 保证数据多线程最终一致性 Copy两份数组，内存浪费。 部分常用集合类的内部实现方式 多线程相关 Thread、Runnable、Callable、Futrue类关系与区别 Thread 实现Runnable接口 提供线程等待、睡眠、礼让等操作 Runnable 接口 无返回值 Callable 接口 有返回值he Future 对Runnable和Callable任务的执行结果进行取消、查询是否完成、获取结构。设置结果等操作 FutureTask Runnable和Future结合 JDK中默认提供了哪些线程池，有何区别 https://batuer.github.io/2018/03/15/Executor/ 线程同步有几种方式，分别阐述在项目中的用法 临界区 通过对多线程串行化来访问公共资源或一段代码，速度快，是个控制数据访问。任何时刻只允许一个线程对共享资源访问。多线程访问时，刚起其它等待线程，一直等到临界区的线程离开。 Step 定义临界区对象Lock 访问共享资源之前，获得临街对象Lock.lock() 访问资源后，放弃临界对象Lock.unlock() 互斥量 (互斥锁) 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，互斥对象只有一个。 信号量 允许多线程访问公共资源，但是限制同一时刻访问该资源的最大线程数 事件 通过通知方式保持线程同步，并可实现优先级操作。 具体实现 同步方法：synchronized修饰方法。 同步代码块：synchronized修饰语句块 同步是一种高开销操作，减少同步内容。没有必要同步整个方法时，同步关键语句块。 特殊域变量(volatile)实现线程同步（可见性） volatile关键字为域变量的访问提供了一种免锁机制 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新 因此每次使用该域就要重新计算，而不是使用寄存器中的值 volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 使用重入锁 在JavaSE5.0中新增了一个java.util.concurrent包来支持同步 ReentrantLock类是可重入、互斥、实现了Lock接口的锁 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力 注：关于Lock对象和synchronized关键字的选择 最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码 如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 使用局部变量实现线程同步 如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响 Volatile与Synchronized 对于volatile修饰的变量，当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的，volatile变量对所有线程是立即可见的，对volatile变量的所有写操作都能立刻反应到其他线程之中。 VM规范规定了任何一个线程修改了volatile变量的值都需要立即将新值更新到主内存中, 任何线程任何时候使用到volatile变量时都需要重新获取主内存的变量值 两者区别 volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化（禁止指令重排序优化，即执行顺序与程序顺序一致）；synchronized标记的变量可以被编译器优化 在理解默认线程池的前提下，自己实现线程池 字符 String的不可变性 不可变对象：基础类型对象之不能改变，引用类型对象的引用不能改变。 节省内存空间 多线程同步 hashcode唯一，效率高 StringBuilder和StringBuffer的区别 StringBuilder线程不安全 StringBuffer线程安全 字符集的理解：Unicode、UTF-8、GB2312等 正则表达式相关问题 注解 http://gusi123.cn/2018/02/24/JavaAnnotaion/ 注解的使用 编写文档 代码分析 编译检查 注解的级别及意义 ​ 如何自定义注解 反射技术解析自定义注解 二、Android技术Android基础 四大组件的意义及使用，生命周期回调及意义 AsyncTask、Handler的使用 https://batuer.github.io/2018/03/23/AsyncTask/ Android系统层次框架结构 https://batuer.github.io/2018/03/21/AnrdroidFrameWork/ AsyncTask的实现方式 https://batuer.github.io/2018/03/23/AsyncTask/ 封装ThreadPoolExecutor和Handler执行线程任务并且完成结果回调。 AsyncTask使用的时候应该注意什么 https://batuer.github.io/2018/03/23/AsyncTask/ 版本不同任务执行方式不同，3.0以上默认串行。 容易造成内存泄漏。 只能执行一次任务。 Android常见的存储方式 内存 外部SD卡 SharedPreferences Sqlite Looper、Handler和MessageQueue的关系 Handler封装消息的发送、接收，内部和Looper关联。 Looper循环从MessageQueue取出消息交给Handler处理。 MessageQueue消息队列，供Looper取。 Activity的启动流程（考察对Framwork的熟悉程度） http://gusi123.cn/2018/03/27/Activity启动流程/ 多进程开发的注意事项(Application类区分进程，进程间内存不可见、进程间通讯方式) http://gusi123.cn/2018/03/26/MultiProcess/ Resource相关 .9图片的意义 style和theme的作用及用法 dpi、sp、px的区别以及转换关系 px是像素，屏幕上实际的像素点单位。 dip/dp设备独立像素，布局常使用，与屏幕有关，在不同像素密度的设备上会自动适配。 sp放大像素，处理字体大小。 dpi 像素密度，每平方英寸中的像素数。 px和dp转换：px=1dp 像素密度(dpi) / 160 =dp density raw和assets文件夹的作用，二者有何区别 两者目录下的文件在打包后会原封不动的保存在apk包中,不会被编译成二进制。 res/raw中的文件会被映射到R.java文件中,访问的时候直接使用资源ID即R.id.filename; 而assets文件夹下的文件不会被映射到R.java中,访问的时候需要AssetManager类。 res/raw不可以有目录结构,而assets则可以有目录结构,也就是assets目录下可以再建立文件夹。 读取res/raw下的文件资源,通过以下方式获取输入流来进行写操作InputStreamis=getResources().openRawResource(R.id.filename);//通过 资源 id 直接打开 raw 下的 流文件 读取assets下的文件资源,通过以下方式获取输入流来进行写操作，InputStream is = getAssets().open(“filename”); Android系统如何在多个资源文件夹下查找匹配最合适的资源 https://www.jianshu.com/p/fd07300b031a 对于资源文件夹的命名必须按照上表中的顺序依次配置，切不可倒置。 虚拟机 Java内存模型 Android虚拟机的特点 Dalvik和Art的区别 熟悉垃圾回收的实现机制，辣椒虚拟机的GC类型 View相关 常用组件的使用：ListView、RecyclerView及Adapter的使用 View之间的继承关系 invalidate和postInvalidate的区别 自定义View onMeasure、onLayout、onDraw的作用 Paint、Matrix、Shader等回执相关类的方法作用 事件分发机制 动画 Android有哪些动画实现方式 Interpolator类的意义和常用的Interpolator ViewAnimation与属性动画有什么区别 如何自定义ViewAnimation 属性动画的实现原理 图片处理 一般项目中如何加载大图 图片压缩方式 如何不压缩图片加载高清图 图片加载过程中，一般会使用缓存，这个缓存的主要作用是什么 图片加载框架对比","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android面试","slug":"Android面试","permalink":"https://batuer.github.io/tags/Android面试/"}]},{"title":"AsyncTask","slug":"AsyncTask","date":"2018-04-13T00:10:25.831Z","updated":"2018-04-13T00:27:55.427Z","comments":true,"path":"2018/04/13/AsyncTask/","link":"","permalink":"https://batuer.github.io/2018/04/13/AsyncTask/","excerpt":"","text":"AsyncTask AsyncTask 是 Android 中一个异步处理的框架，它内部集成了线程池和 Handler 机制，实现了异步任务加载和主线程更新 UI 的功能，在 Android 中不同的版本的 AsyncTask 却有点不一样。 Android中工作者线程主要有AsyncTask、IntentService、HandlerThread，它们本事上都是对线程或线程池的封装。(ThreadPoolExecutor) 使用简介 AsyncTask是对Handler与线程池的封装。AsyncTask内部包含一个Handler，方便更新UI。使用线程池 onPreExecute() //此方法会在后台任务执行前被调用，用于进行一些准备工作 doInBackground(Params… params) //此方法中定义要执行的后台任务，在这个方法中可以调用publishProgress来更新任务进度（publishProgress内部会调用onProgressUpdate方法） onProgressUpdate(Progress… values) //由publishProgress内部调用，表示任务进度更新 onPostExecute(Result result) //后台任务执行完毕后，此方法会被调用，参数即为后台任务的返回结果 onCancelled() //此方法会在后台任务被取消时被调用 以上方法中，除了doInBackground方法由AsyncTask内部线程池执行外，其余方法均在主线程中执行。 局限性 Android4.1之前AsyncTask类必须在主线程中加载。 在Android 4.1以及以上版本则不存在这一限制，因为ActivityThread（代表了主线程）的main方法中会自动加载AsyncTask 。 一个AsyncTask对象只能调用一次execute方法。","categories":[{"name":"AsyncTask","slug":"AsyncTask","permalink":"https://batuer.github.io/categories/AsyncTask/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"AsyncTask","slug":"AsyncTask","permalink":"https://batuer.github.io/tags/AsyncTask/"}]},{"title":"Dart","slug":"Dart","date":"2018-04-13T00:10:25.831Z","updated":"2018-04-13T00:10:25.831Z","comments":true,"path":"2018/04/13/Dart/","link":"","permalink":"https://batuer.github.io/2018/04/13/Dart/","excerpt":"","text":"Dart基础学习。List 固定长度的列表，一旦定义无法改变。 12345678910void _fixedList() &#123; List&lt;int&gt; list = new List(3); list[0] = 0; list[1] = 1; for (var value in list) &#123; print('Fire:' + value.toString()); &#125; //错误:Unsupported operation: Cannot add to a fixed-length list //list.add(4); &#125; 可变长度，动态加减。 1234567891011void _growableList() &#123; List&lt;int&gt; list = [0, 1]; print('Fire:' + list[1].toString()); list[1] = 11; print('Fire:' + list[1].toString()); //add list.add(3); for (var value in list) &#123; print('Fire:DartTest:29:' + value.toString()); &#125; &#125; 几种构造。 123456789101112// 创建固定长度的列表 List fixedLengthList = new List(3);// 创建可改变长度的列表 List growableListA = new List();// 创建包含所有元素的固定长度列表 List fixedLengthListB = new List.unmodifiable([1, 2, 3]);// 创建包含所有元素的可改变长度列表 List growableListC = new List.from([1, 2, 3]);// 用生成器给所有元素赋初始值 List fixedLengthList = new List&lt;int&gt;.generate(4, (int index) &#123; return index * index; &#125;); 排序。 123456789101112131415void _listSort() &#123; List&lt;int&gt; list = [1, 3, 2, 5, 6, 7, 4]; list.sort((a, b) &#123; return a.compareTo(b); &#125;); print('Fire:DartTest:47:' + list.join(\",\")); list.sort((a, b) &#123; return a - b; &#125;); print('Fire:DartTest:51:' + list.join(\",\")); list.sort((a, b) &#123; return b - a; &#125;); print('Fire:DartTest:55:' + list.join(\",\")); &#125; Map 键值对，每个键对应一个值。 几种构造。 12345678910111213141516171819202122232425262728293031void _map() &#123; // Map&lt;String, int&gt; map = &#123;\"a\": 1, \"b\": 2&#125;; print('DartTest:62:' + map.keys.join(\",\") + \":\" + map.values.join(\",\")); map.addAll(&#123;\"c\": 3&#125;); print('DartTest:65:' + map.keys.join(\",\") + \":\" + map.values.join(\",\")); map.addAll(&#123;\"a\": 11&#125;); print('DartTest:67:' + map.keys.join(\",\") + \":\" + map.values.join(\",\")); // Map&lt;String, int&gt; map1 = Map.castFrom(map); print('DartTest:70:' + map1.keys.join(\",\") + \":\" + map1.values.join(\",\")); // List&lt;MapEntry&lt;String, int&gt;&gt; list = [ new MapEntry(\"a\", 1), new MapEntry(\"b\", 2) ]; Map&lt;String, int&gt; mapFromEntries = new Map.fromEntries(list); // List&lt;String&gt; list1 = [\"4\", \"5\"]; List&lt;int&gt; list2 = [1, 2]; var map2 = new Map.fromIterables(list1, list2); print('DartTest:82:' + map2.keys.join(\",\") + map2.values.join(\",\")); Map&lt;String, String&gt; map3 = new Map.fromIterable(list1, key: (item) =&gt; item, value: (item) =&gt; item); Map&lt;String, String&gt; map4 = new Map.fromIterable(list2, key: (item) &#123; item.toString(); &#125;, value: (item) &#123; item.toString(); &#125;); &#125; Set 每个对象只能出现一次，不能重复。 命名参数 用 { } 把参数包装起来，就能标识命名参数。 用 : 指定默认值。 1234567891011void test() &#123; _parameter(name: \"xiaoming\", age: 11); _parameter(name: \"xiaoming\", age: 11, sex: \"woman\"); _parameter1(\"小明\", 22, \"man\"); &#125; //用 &#123; &#125; 把参数包装起来，就能标识命名参数。 //用 : 指定默认值 void _parameter(&#123;String name, int age, String sex: 'man'&#125;) &#123;&#125; void _parameter1(String name, int age, String sex) &#123;&#125; 位置参数 用[ ] 把参数包括起来，标示参数位置 用=指定默认值 123456789101112131415161718192021222324252627void test() &#123; _parameterPos(\"小明\", \"11\"); _parameterPos(\"小明\", \"11\", \"sex\", 11); &#125; // 用 [ ] 把参数包装起来，就能标识位置参数 // 用 = 指定默认值 void _parameterPos(String name, String age, [String sex, int height]) &#123; StringBuffer sb = new StringBuffer(); sb.write(\"name_\"); if (name != null) &#123; sb.write(name); &#125; sb.write(\" age_\"); if (age != null) &#123; sb.write(age); &#125; sb.write(\" sex_\"); if (sex != null) &#123; sb.write(sex); &#125; sb.write(\" height_\"); if (height != null) &#123; sb.write(height); &#125; print('Fire:DartTest:27:' + sb.toString()); &#125; 高阶函数 将一个函数当作参数传递。 123456789101112void test() &#123; List&lt;String&gt; list = [\"a\", \"b\"]; list.forEach((item) &#123; _printElement(item); &#125;); list.forEach(_printElement); &#125; //将一个函数当作参数传递 void _printElement(Object obj) &#123; print('Fire:DartTest:11:' + obj.toString()); &#125; 将一个函数分配给变量。 12345void test() &#123; //将一个函数分配给一个变量 var loudify = (msg) =&gt; \"将一个函数分配给一个变量:$&#123;msg.toUpperCase()&#125;\"; print('Fire:DartTest:14:' + loudify('hello')); &#125; 闭包函数 dart的闭包就是函数对象，其实跟JavaScript的闭包函数差不多，理论请参考JavaScript的闭包函数。 123456789void test() &#123; var makeAddBy2 = makeAddBy(num: 2); var makeAddBy3 = makeAddBy(num: 3); print('Fire:DartTest:9:' + makeAddBy3(5).toString()); print('Fire:DartTest:8:' + makeAddBy2(3).toString()); &#125; Function makeAddBy(&#123;int num&#125;) &#123; return (int i) =&gt; i + num; &#125; 泛型 dart中所有基本类型数组和列表都是泛型，这样可以提高代码的可读性。 减少代码。 提前检查。 异常 dart会抛出并捕获异常，如果没有捕获异常，就会中断运行或结束程序。 与Java不同的是dart的所有异常都是未经检查的。 dart提供了Exception、Error类型，以及更多的子类型，也可以自定义异常。 1234567891011121314151617181920212223242526void _exception() &#123;// //// if (true) &#123;// throw new Exception(\"异常\");// &#125;// //自定异常// if (true) &#123;// throw \"自定义异常\";// &#125; //捕获并处理 try &#123; if (true) &#123; throw new Exception(\"异常\"); &#125; &#125; on Exception &#123; print('Fire:DartTest:24:' + '捕获异常'); &#125; // try &#123; if (true) &#123; throw new Exception(\"异常\"); &#125; &#125; on Exception catch (e) &#123; print('Fire:DartTest:24:' + '捕获异常:' + e.toString()); &#125; finally &#123;&#125; &#125; 实例变量 声明实例变量，未初始化为null。 构造函数 默认无参构造。 命名构造。 1DartTest.fromJson(String json) &#123;&#125; 子类构造函数调用父类的默认构造函数，如果父类没有默认构造函数，必须手动调用父类的构造函数。 重定向构造。 123DartTest(&#123;int a&#125;) &#123;&#125; DartTest.fromJson(int b) : this(a: b); 常量构造。声明const 构造，并且确保实例变量是final的。 1234//常量构造 const DartTest(); static final DartTest dartTest = new DartTest(); 抽象类 使用abstract修饰符定义的抽象类不能被实例化。 用于定义接口。 有抽象方法的一定是抽象类，反之则不然。 隐式接口 每个类都有一个隐式定义的接口，包含所有非私有方法和变量。 implements 实现一个或多个接口。 1234567891011121314151617181920class Person &#123; final _name; int height; int _width; Person(this._name); String greet(who) =&gt; \"Hello, $who. I am $_name.\"; void _test()&#123;&#125;&#125;class PersonIml implements Person &#123; @override// String greet(who) =&gt; \"-------\"; String greet(who) &#123; return \"-----\"; &#125; @override int height;&#125;","categories":[{"name":"Dart","slug":"Dart","permalink":"https://batuer.github.io/categories/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://batuer.github.io/tags/Dart/"}]},{"title":"Android FrameWork","slug":"AnrdroidFrameWork","date":"2018-04-13T00:10:25.831Z","updated":"2018-04-13T00:10:25.831Z","comments":true,"path":"2018/04/13/AnrdroidFrameWork/","link":"","permalink":"https://batuer.github.io/2018/04/13/AnrdroidFrameWork/","excerpt":"","text":"Android 的四个层次Android应用层 用Java、Kotlin或其它语言编写的运行在虚拟机上的程序。eg：Google原生的短信、浏览器或自己开发的程序。 FrameWork（框架层） Google核心应用是所使用的API框架，开发人员也可以使用用于开发自己的程序，但必须遵守框架的开发原则。 包含：丰富而又可扩展的视图层各种View ContentProvider：多进程间数据哭数据共享 ResourceManager：提供资源的访问，包括字符串、图形、布局文件等。 NotifyManager：消息通知 ActivityManager：应用程序生命周期管理 WindowManager：窗口管理 … 系统运行层 这一层通过一些c/c++库位Android系统提供了支持。eg：Sqlite数据库、OpenGl|ES绘图的支持、Webkit浏览器内核的支持。 这一层还有Android运行核心库。每一个Android应用程序都在自己的进程中进行，拥有独立Dalvik虚拟机。Dalvik虚拟一依赖于LInux内核的一些功能，如底层内存管理机制和线程机制。 LInux内核 驱动层 进程通信的Binder 电源管理","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://batuer.github.io/categories/FrameWork/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"FrameWork","slug":"FrameWork","permalink":"https://batuer.github.io/tags/FrameWork/"}]},{"title":"Githug","slug":"Githug","date":"2018-04-13T00:10:25.831Z","updated":"2018-04-13T00:10:25.832Z","comments":true,"path":"2018/04/13/Githug/","link":"","permalink":"https://batuer.github.io/2018/04/13/Githug/","excerpt":"","text":"Githug 安装及命令 [Github链接]: https://github.com/Gazler/githug 安装Ruby 1.8.7 or higher gem install githug 如果遇到权限问题，请加上sudo：sudo gem install githug Commands play hint reset levels 开始游戏 GitLevels 使用githug hint命令根据提示完成，用githug play验证完成结果。","categories":[{"name":"Git","slug":"Git","permalink":"https://batuer.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://batuer.github.io/tags/Git/"}]},{"title":"ExecutorService和Executors","slug":"Executor","date":"2018-04-13T00:10:25.831Z","updated":"2018-04-13T00:10:25.831Z","comments":true,"path":"2018/04/13/Executor/","link":"","permalink":"https://batuer.github.io/2018/04/13/Executor/","excerpt":"","text":"1. newFixedThreadPool 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。 该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。 newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。 其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子 。 和cacheThreadPool不同，FixedThreadPool没有IDLE机制，所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器 。 从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同。 fixed池线程数固定，并且是0秒IDLE（无IDLE），cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE。 重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。 固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。 超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的） 使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。 源码分析：从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同： fixed池线程数固定，并且是0秒IDLE（无IDLE）。 cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE。 2. newCachedThreadPool 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。 该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。 缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中 。 缓存型池子通常用于执行一些生存期很短的异步型任务。 能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。 注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。 重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。 使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。 超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。 结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。 3. newSingleThreadExecutor 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。 该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。 单例线程，任意时间池中只能有一个线程 。 用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）。 SingleThreadExecutor得到的是一个单个的线程，这个线程会保证你的任务执行完成。 如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。 4. newScheduledThreadPool 调度型线程池，这个池子里的线程可以按schedule依次delay执行，或周期执行。 该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。 ScheduledThreadPool是一个固定大小的线程池，与FixedThreadPool类似，执行的任务是定时执行。 5. Android性能优化之使用线程池处理异步任务 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失。 大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM。 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿。 6. 使用线程池管理线程的优点 ExecutorService是一个接口，线程池服务。 hreadPoolExecutor实现ExecutorService接口封装了一系列API是的它具有线程池的特性，包括工作队列，核心线程池数，最大线程池数。 管理线程，节省内存资源，减小消耗。 7. shutdown()和shutdownNow()的区别 shutdown()方法在终止前允许执行以前提交的任务。不再接受新的任务。 shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。","categories":[{"name":"Executors","slug":"Executors","permalink":"https://batuer.github.io/categories/Executors/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://batuer.github.io/tags/线程/"},{"name":"Executors","slug":"Executors","permalink":"https://batuer.github.io/tags/Executors/"}]},{"title":"Activity启动流程","slug":"Activity启动流程","date":"2018-04-13T00:10:25.830Z","updated":"2018-06-26T14:32:56.510Z","comments":true,"path":"2018/04/13/Activity启动流程/","link":"","permalink":"https://batuer.github.io/2018/04/13/Activity启动流程/","excerpt":"","text":"https://www.jianshu.com/p/9ecea420eb52 一切从main()开始Android中，一个应用程序的开始从ActivityThread.java中的main()开始。 配置程序运行环境UserEnvironment,日志等。 准备当前线程的Looper为程序的MainLooper。 初始化ActivityThread实例 ActivityThread实例调用attach(false)，创建Application 获取MainThreadHandler MainLooper开始loop(),接收发送消息。程序开始运行。 创建Application的消息ActivityThread实例调用attach(false)，创建Application 判断是否系统程序，不同的初始化流程(分析非系统) 获得ActivityManager实例——ActivityManagerService，ActivityManagerNative.getDefault()获得代理类ActivityManagerProxy，通过ServiceManager获得IBinder实例。获取IBInder目的既是为了通过这个IBinder和ActivityManager进行通讯。 12345IBinder b = ServiceManager.getService(\"activity\");if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b);&#125;IActivityManager am = asInterface(b); 123456789101112static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj); &#125; ActivityManagerProxy.attachApplication(mAppThread) 12345678Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app.asBinder()); mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data,reply,0); reply.readException(); data.recycle(); reply.recycle(); 调用IBInder实例的tansact()方法，把参数app放到data中，最终传递给ActivityManager。 IActvitymanager的实现类ActivityManagerProxy。 ApplicationThread mAppThread ？ 12private class ApplicationThread extends ApplicationThreadNative &#123;&#125; 123public abstract class ApplicationThreadNative extends Binder implements IApplicationThread &#123; &#125; 123public interface IApplicationThread extends IInterface &#123; String descriptor = \"android.app.IApplicationThread\";&#125; ​ ActivityThread 中的常量，不希望中途被修改。 ApplicationThread是ActivityThread内部类。 ApplicationThreadNative继承Binder实现IApplicationThread。 ApplicationThread作为IApplicationThread实例承担了最后发送Activity生命周期、及其它一些任务。ApplicationThread传到ActivityManager中为了让系统根据情况控制。 ​ ActivityManagerService调度发送初始化消息12public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123;&#125; 123public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;&#125; 获得ActivityManager实例——ActivityManagerService 123456final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; 实现类ActivityManagerService 123456789@Override public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125; &#125; attachApplicationLocked() 123456789private final boolean attachApplicationLocked(IApplicationThread thread,int pid) &#123; // 以前存在 pid // If the app is being launched for restore or full backup, set it up specially ... //实现类ApplicationThread 执行bindApplication初始化Application thread.bindApplication(...); ... return true; &#125; 12345678910public final void bindApplication(...) &#123; if (services != null) &#123; // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); ... sendMessage(H.BIND_APPLICATION, data); &#125; 123456case BIND_APPLICATION: AppBindData data = (AppBindData)msg.obj; //重要 handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);break; 123456789101112131415private void handleBindApplication(AppBindData data) &#123; ... //通过反射初始化一个Instrumentation仪表。 mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()) .newInstance(); ... //通过LoadedApp命令创建Application实例 Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... mInstrumentation.callApplicationOnCreate(app); //让仪器调用Application的onCreate()方法 ...&#125; Instrumentation ? Instrumentation会在应用程序的任何代码运行之前被实例化，它能够允许你监视应用程序和系统的所有交互。 收集AndroidManifest.xml标签信息 Apllication的创建，Activity的创建，以及生命周期都会经过这个对象去执行。简单点说，就是把这些操作包装了一层。通过操作Instrumentation进而实现上述的功能。 123public void callApplicationOnCreate(Application app) &#123; app.onCreate(); &#125; LoadedApk就是data.info1234567891011121314public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; ... String appClass = mApplicationInfo.className; //Application的类名。明显是要用反射了。 ... ContextImpl appContext = ContextImpl.createAppContext(mActivityThread , this); //留意下Context app = mActivityThread.mInstrumentation .newApplication( cl, appClass, appContext); //通过仪表创建Application ...&#125; 在取得Application的实际类名之后，最终的创建工作还是交由Instrumentation去完成，就像前面所说的一样。 回Instrumentation1234567static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = (Application)clazz.newInstance(); app.attach(context); return app; &#125; LaunchActivity当Application初始化完成后，系统会根据Manifests中的配置启动Activity发送一个Intent去启动相对应的Activity。 12345678910111213141516171819202122232425262728293031323334353637 // we use token to identify this activity without having to send the// activity itself back to the activity manager. (matters more with ipc)@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); //启动Activity sendMessage(H.LAUNCH_ACTIVITY, r); &#125; H 接收到LAUNCH_ACTIVITY的消息，开始初始化Activity，ActivityThread.handleLaunchActivity() 12345678910private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; // gc、Profiler、Config、WindowManagerGlobal //... Activity a = performLaunchActivity(r,customIntent); if (a != null) &#123; //Config... //onResume handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); &#125; performLaunchActivity() 1234567891011121314151617181920212223242526272829private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //Instrumentation 创建Activity Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //反射创建Activity实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); &#125; catch (Exception e) &#123; &#125; //获取Application，r.packageInfo就是LoadApk try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; //... activity.attach( appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor,window); //持久化 Instrumentation执行Activity的onCreate() //Mainfiset下Activity标签 // ersistableMode == persistAcrossReboots if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate( activity,r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate( activity, r.state); &#125; //... return activity; &#125; Application 创建完成，第一个Activity创建完成。","categories":[{"name":"Activity","slug":"Activity","permalink":"https://batuer.github.io/categories/Activity/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"https://batuer.github.io/tags/Activity/"}]}]}