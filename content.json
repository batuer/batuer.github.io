{"meta":{"title":"YlwBlog","subtitle":null,"description":"Keep learning!","author":"Yuliwen","url":"https://batuer.github.io"},"pages":[],"posts":[{"title":"Sql练习","slug":"Sql","date":"2018-12-18T13:34:39.088Z","updated":"2018-12-18T13:34:39.088Z","comments":true,"path":"2018/12/18/Sql/","link":"","permalink":"https://batuer.github.io/2018/12/18/Sql/","excerpt":"","text":"基础练习 查询Student表中的所有记录的Sname、Ssex和Class列。 1SELECT sname,ssex,class From students 查询教师所有的单位即不重复的Depart列。 1SELECT DISTINCT depart From teachers 查询Student表的所有记录。 1SELECT * From students 查询Score表中成绩在60到80之间的所有记录。 1SELECT * From scores WHERE degree BETWEEN 60 And 80 查询Score表中成绩为85，86或88的记录。 123SELECT * From scores WHERE degree = 85 or degree = 86 or degree =88 SELECT * From scores WHERE degree IN (85,86,88) 查询Student表中“95031”班或性别为“女”的同学记录。 1SELECT * From students WHERE class = '95031' OR ssex = '女' 以Class降序查询Student表的所有记录。 1SELECT * From students ORDER BY class DESC 以Cno升序、Degree降序查询Score表的所有记录。 1SELECT * From scores ORDER BY cno ASC,degree DESC 查询“95031”班的学生人数。 123SELECT COUNT(*) From students WHERE class = '95031'SELECT COUNT(1) AS StuNum FROM Students WHERE Class = '95031' 查询Score表中的最高分的学生学号和课程号。 123SELECT sno,cno From scores ORDER BY degree DESC LIMIT 1SELECT MAX(degree) From scores //查询最大值 查询‘3-105’号课程的平均分。 1SELECT AVG(degree) From scores WHERE cno = '3-105' 查询Score表中至少有5名学生选修的并以3开头的课程的平均分数。 1SELECT cno,AVG(degree) From scores WHERE cno LIKE '3%' GROUP BY cno HAVING COUNT(sno) &gt; 5 查询最低分大于70，最高分小于90的Sno列。 1SELECT sno From scores GROUP BY sno HAVING MIN(degree) &gt; 70 And MAX(degree) &lt; 90 查询所有学生的Sname、Cno和Degree列。 1SELECT st.sname,sc.cno,sc.degree From students st JOIN scores sc On sc.sno = st.sno 查询所有学生的Sno、Cname和Degree列。 123SELECT st.sname,sc.cno,sc.degree From students st JOIN scores sc On sc.sno = st.snoSELECT st.sname,sc.cno,sc.degree From students st JOIN scores sc On (sc.sno = st.sno) 查询所有学生的Sname、Cname和Degree列。 123SELECT st.sname,sc.cno,sc.degree From students st JOIN scores sc On sc.sno = st.snoSELECT st.sname,sc.cno,sc.degree From students st JOIN scores sc On (sc.sno = st.sno) 查询“95033”班所选课程的平均分。 1SELECT courses.cname,AVG(degree) FROM scores JOIN students ON students.sno = scores.sno JOIN courses ON scores.cno = courses.cno WHERE students.class = '95033' GROUP BY courses.cno; 假设使用如下命令建立了一个grade表： 1234567891011CREATE TABLE grade(low TINYINT,upp TINYINT,rank CHAR(1));INSERT INTO grade VALUES(90,100,'A');INSERT INTO grade VALUES(80,89,'B');INSERT INTO grade VALUES(70,79,'C');INSERT INTO grade VALUES(60,69,'D');INSERT INTO grade VALUES(0,59,'E'); 现查询所有同学的Sno、Cno和rank列。 1SELECT sc.sno,sc.cno,sc.degree,g.rank FROM scores sc JOIN grade g ON (sc.degree &gt;= g.low AND sc.degree &lt;= g.upp) ORDER BY g.rank ASC,sc.sno ASC; 查询选修“3-105”课程的成绩高于“109”号同学成绩的所有同学的记录。 123SELECT sc.sno,sc.degree FROM students st JOIN scores sc ON sc.sno = st.sno WHERE sc.cno = '3-105' AND sc.degree &gt; (SELECT sc.degree FROM scores sc WHERE sc.sno = '109' AND sc.cno = '3-105');SELECT s1.Sno,s1.Degree FROM Scores AS s1 INNER JOIN Scores AS s2 ON (s1.Cno = s2.Cno AND s1.Degree &gt; s2.Degree) WHERE s1.Cno = '3-105' AND s2.Sno = '109' ORDER BY s1.Sno; 查询score中选学一门以上课程的同学中分数为非最高分成绩的记录。 1SELECT * From scores GROUP BY sno HAVING COUNT(sno) &gt; 1 AND degree != MAX(degree); 查询成绩高于学号为“109”、课程号为“3-105”的成绩的所有记录。 123SELECT * From scores WHERE cno = '3-105' AND degree &gt; (SELECT degree FROM scores WHERE sno = '109' AND cno = '3-105');SELECT s1.Sno,s1.Degree FROM Scores AS s1 INNER JOIN Scores AS s2 ON (s1.Cno = s2.Cno AND s1.Degree &gt; s2.Degree) WHERE s1.Cno = '3-105' AND s2.Sno = '109' ORDER BY s1.Sno; 查询和学号为108的同学同年出生的所有学生的Sno、Sname和Sbirthday列。 123SELECT st.sno,st.sname,st.sbirthday FROM students st WHERE YEAR (st.Sbirthday) = (SELECT YEAR(sbirthday) FROM students WHERE sno = '108') AND st.sno != '108';SELECT s1.Sno,s1.Sname,s1.Sbirthday FROM Students AS s1 INNER JOIN Students AS s2 ON (YEAR (s1.Sbirthday) = YEAR (s2.Sbirthday)) WHERE s2.Sno = '108' AND s1.sno != '108'; 查询“张旭“教师任课的学生成绩。 1SELECT sc.degree FROM scores sc JOIN courses c On sc.cno = c.cno JOIN teachers t On t.tno = c.tno WHERE t.tname = '张旭'; 查询选修某课程的同学人数多于5人的教师姓名。 12345SELECT cno From scores GROUP BY cno HAVING COUNT(sno) &gt; 5;SELECT t.tname FROM scores sc JOIN courses c ON c.cno = sc.cno JOIN teachers t ON t.tno = c.tno GROUP BY c.tno HAVING(count(sno) &gt; 5); SELECT DISTINCT t.tname FROM scores sc JOIN courses c ON sc.cno = c.cno JOIN teachers t On t.tno = c.tno WHERE c.cno in (SELECT cno From scores GROUP BY cno HAVING COUNT(sno) &gt; 5); 查询95033班和95031班全体学生的记录。 1SELECT * FROM Students WHERE Class IN ('95033','95031') ORDER BY Class; 查询存在有85分以上成绩的课程Cno. 1SELECT DISTINCT Cno FROM Scores WHERE Degree &gt; 85; 查询出“计算机系“教师所教课程的成绩表。 1SELECT sc.degree,t.depart FROM scores sc Join courses c On c.cno = sc.cno JOIN teachers t On t.tno = c.tno WHERE t.depart = '计算机系'; 查询“计算机系”与“电子工程系“不同职称的教师的Tname和Prof。 123SELECT Tname,Prof FROM Teachers WHERE Depart='计算机系' AND Prof NOT IN( SELECT DISTINCT Prof FROM Teachers WHERE Depart='电子工程系'); SELECT tname,prof FROM teachers WHERE depart ='电子工程系' And prof NOT IN(SELECT DISTINCT prof FROM teachers WHERE depart = '计算机系'); 查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序。 1SELECT sc.cno,sc.sno,sc.degree FROM scores sc WHERE sc.cno = '3-105' AND sc.degree &gt; ANY (SELECT degree FROM scores WHERE cno = '3-245') ORDER BY sc.degree DESC; 查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree. 1SELECT sc.cno,sc.sno,sc.degree FROM scores sc WHERE sc.cno = '3-105' AND sc.degree &gt;ALL(SELECT degree FROM scores WHERE cno = '3-245') ORDER BY sc.degree DESC; 查询所有教师和同学的name、sex和birthday. 1SELECT tname,tsex,tbirthday From teachers UNION Select sname,ssex,sbirthday FROM students; 查询所有“女”教师和“女”同学的name、sex和birthday. 1SELECT tname,tsex,tbirthday From teachers WHERE tsex = '女' UNION Select sname,ssex,sbirthday FROM students WHERE ssex = '女'; 查询成绩比该课程平均成绩低的同学的成绩表。 123SELECT sc.* From scores sc WHERE sc.degree &lt; (SELECT AVG(degree) FROM scores WHERE cno = sc.cno) ORDER BY sc.sno;SELECT s1.* FROM Scores AS s1 JOIN (SELECT Cno,AVG(Degree) AS aDegree FROM Scores GROUP BY Cno) s2 ON(s1.Cno=s2.Cno AND s1.Degree&lt;s2.adegree) ORDER BY s1.sno; 查询所有任课教师的Tname和Depart. 12345SELECT te.tname,te.depart FROM teachers te Where te.tno In (SELECT tno From courses);SELECT te.tname,te.depart FROM teachers te Where te.tno In (SELECT tno From courses WHERE cno IN (SELECT sc.cno From scores sc ));SELECT Tname,Depart FROM Teachers WHERE Tno IN(SELECT Tno FROM Courses); 查询所有未讲课的教师的Tname和Depart. 12345SELECT te.tname,te.depart FROM teachers te Where te.tno not In (SELECT tno From courses);SELECT te.tname,te.depart FROM teachers te Where NOT EXISTS (SELECT tno From courses WHERE tno = te.tno);SELECT Tname,Depart FROM Teachers WHERE Tno not IN(SELECT Tno FROM Courses);SELECT Tname,Depart FROM Teachers WHERE NOT EXISTS (SELECT tno FROM courses WHERE tno = teachers.tno); 查询至少有2名男生的班号。 123SELECT st.class,COUNT(sno) boycount FROM students st WHERE st.ssex ='男' GROUP BY st.class HAVING boycount &gt;= 2;SELECT Class,COUNT(1) AS boyCount FROM Students WHERE Ssex='男' GROUP BY Class HAVING boyCount&gt;=2; 查询Student表中不姓“王”的同学记录。 1SELECT * FROM students WHERE sname not LIKE '王%'; 查询Student表中每个学生的姓名和年龄。 123SELECT sname,sbirthday FROM students ;SELECT Sname,YEAR(NOW())-YEAR(Sbirthday) AS Sage FROM Students; 查询Student表中最大和最小的Sbirthday日期值。 123SELECT MAX(DAY(sbirthday)) maxDay,MIN(DAY(sbirthday)) minDay FROM students ; SELECT MIN(Sbirthday),MAX(Sbirthday) FROM Students; 以班号和年龄从大到小的顺序查询Student表中的全部记录。 1SELECT * FROM students GROUP BY class DESC, sbirthday ASc; 查询“男”教师及其所上的课程。 1SELECT te.*,c.* FROM teachers te JOIN courses c On c.tno = te.tno WHERE te.tsex ='男'; 查询最高分同学的Sno、Cno和Degree列。 123SELECT sno,cno,degree FROM scores WHERE degree = (SELECT MAX(degree) FROM scores);SELECT * FROM Scores GROUP BY Cno HAVING Degree=Max(Degree); 查询和“李军”同性别的所有同学的Sname. 123SELECT sname FROM students WHERE ssex = (SELECT s1.ssex FROM students s1 WHERE s1.sname = '李军') AND sname != '李军'; SELECT s1.sname From students s1 JOIN students s2 On (s1.ssex = s2.ssex) WHERE s2.sname = '李军' And s1.sname != '李军'; 查询和“李军”同性别并同班的同学Sname. 1SELECT s1.sname From students s1 JOIN students s2 On (s1.ssex = s2.ssex And s1.class = s2.class) WHERE s2.sname = '李军' And s1.sname != '李军'; 查询所有选修“计算机导论”课程的“男”同学的成绩表。 123SELECT sc.* FROM scores sc JOIN students st On st.sno = sc.sno JOIN courses c On c.cno = sc.cno WHERE c.cname = '计算机导论' And st.ssex = '男';SELECT * FROM Scores WHERE Sno IN (SELECT Sno FROM Students WHERE Ssex='男') AND Cno IN (SELECT Cno FROM Courses WHERE Cname='计算机导论'); 经典练习 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数。 1234SELECT st.*,sc1.* FROM sc sc1 JOIN sc sc2 On (sc1.sId = sc2.sid) JOIN student st On sc1.SId = st.SId WHERE sc1.CId = '01' And sc2.cid = '02' And sc1.score &gt; sc2.score;select * from Student RIGHT JOIN (select t1.SId, class1, class2 from (select SId, score as class1 from sc where sc.CId = '01')as t1, (select SId, score as class2 from sc where sc.CId = '02')as t2 where t1.SId = t2.SId AND t1.class1 &gt; t2.class2)r on Student.SId = r.SId; 查询同时存在” 01 “课程和” 02 “课程的情况。 123SELECT sc1.sid FROM sc sc1 JOIN sc sc2 On sc1.sid = sc2.sid WHERE sc1.cid ='01' And sc2.CId = '02';select * from (select * from sc where sc.CId = '01') as t1, (select * from sc where sc.CId = '02') as t2 where t1.SId = t2.SId; 查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )。 123SELECT sc1.sid,sc1.cid,sc2.cid FROM sc sc1 Left JOIN sc sc2 On (sc1.sid = sc2.sid And sc2.cid = '02') WHERE sc1.cid = '01';select * from (select * from sc where sc.CId = '01') as t1 left join (select * from sc where sc.CId = '02') as t2 on t1.SId = t2.SId; 查询不存在” 01 “课程但存在” 02 “课程的情况。 1select * from sc where sc.SId not in (select SId from sc where sc.CId = '01') AND sc.CId= '02'; 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩。 1234SELECT st.*,sum(sc.score),avg(sc.score) as avgsum From sc JOIN student st On sc.SId = st.sid GROUP BY st.SId HAVING(avgsum &gt;= 60);select student.SId,sname,ss from student,(select SId, AVG(score) as ss from sc GROUP BY SId HAVING AVG(score)&gt;= 60) rwhere student.sid = r.sid; 查询在 SC 表存在成绩的学生信息。 12345SELECT st.* From student st WHERE EXISTS (SELECT sc.SId From sc WHERE sc.SId = st.SId);SELECT st.* FROM student st WHERE st.SId in (SELECT sc.sid From sc);select DISTINCT student.* from student,sc where student.SId=sc.SId; 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )。 1234567SELECT st.sid,st.Sname,count(sc.sid),sum(sc.score) From student st JOIN sc On sc.SId = st.SId GROUP BY st.SId;SELECT st.sid,st.Sname,count(sc.sid),sum(sc.score) From student st Left JOIN sc On sc.SId = st.SId GROUP BY st.SId;select student.sid, student.sname,r.coursenumber,r.scoresum from student,(select sc.sid, sum(sc.score) as scoresum, count(sc.cid) as coursenumber from sc group by sc.sid)r where student.sid = r.sid;select s.sid, s.sname,r.coursenumber,r.scoresum from ((select student.sid,student.sname from student)s left join (select sc.sid, sum(sc.score) as scoresum, count(sc.cid) as coursenumber from sc group by sc.sid)r on s.sid = r.sid); 查有成绩的学生信息。 123SELECT st.* From student st WHERE EXISTS (SELECT sc.SId From sc WHERE sc.SId = st.SId);SELECT st.* From student st WHERE st.SId in (SELECT sc.sid From sc); 查询「李」姓老师的数量。 123SELECT COUNT(TId) FROM teacher WHERE Tname like '李%';SELECT COUNT(*) FROM teacher WHERE Tname like '李%';//自动最优 查询学过「张三」老师授课的同学的信息。 123SELECT st.* From student st JOIN sc On sc.SId = st.SId JOIN course On course.CId = sc.CId JOIN teacher On teacher.TId = course.TId WHERE teacher.Tname = '张三'; select student.* from student,teacher,course,sc where student.sid = sc.sid and course.cid=sc.cid and course.tid = teacher.tid and tname = '张三'; 查询没有学全所有课程的同学的信息。 123select * from student where student.sid not in (select sc.sid from sc group by sc.sid having count(sc.cid)= (select count(cid) from course));SELECT st.* From student st Left Join sc On sc.SId = st.SId GROUP BY st.SId HAVING count(sc.SId) &lt; (SELECT COUNT(cid) FROM course); 查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息。 1234select * from student where student.sid in (select sc.sid from sc where sc.cid in(select sc.cid from sc where sc.sid = '01'));SELECT DISTINCT st.* From sc JOIN student st On st.SId = sc.SId Join course On course.CId = sc.CId WHERE course.CId in (SELECt course.cid From sc JOIN student st On st.SId = sc.SId JOIN course On course.CId = sc.CId WHERE st.SId = '01') And st.SId != '01' ; 查询和” 01 “号的同学学习的课程 完全相同的其他同学的信息。 12SELECT st.* From sc JOIN course On course.CId = sc.CId JOIN student st On st.SId = sc.SId GROUP BY st.sid HAVING count(course.cid) = (SELECT count(course.cid) From sc JOIN course On course.CId = sc.CId WHERE sc.SId = '01'); 查询没学过”张三”老师讲授的任一门课程的学生姓名。 123SELECT st.* From student st,teacher,course,sc WHERE st.SId = sc.SId And course.CId = sc.CId And course.TId = teacher.TId And teacher.Tname = '张三';//多表联合查询select * from student where student.sid not in(select sc.sid from sc,course,teacher where sc.cid = course.cid and course.tid = teacher.tid and teacher.tname= \"张三\"); 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩。 1SELECT st.SId,st.sname,avg(sc.score) From sc JOIN student st On sc.SId = st.SId WHERE sc.score &lt; 60 GROUP BY sc.SId HAVING COUNT(sc.SId) &gt;= 2; 检索” 01 “课程分数小于 60，按分数降序排列的学生信息。 1SELECT student.* From sc,student WHERE sc.SId = student.SId And sc.CId = '01' And sc.score &lt; 60 ORDER BY sc.score DESC; 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩。 1SELECT * From sc LEFT JOIN (SELECT sid,avg(score) as avgScore From sc GROUP BY sid)r On r.sid = sc.SId ORDER BY r.avgScore Desc; 查询各科成绩最高分、最低分和平均分：以如下形式显示： 以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率 及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90 要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 1234567SELECT sc.cid,course.cname,MAX(sc.score) as 最高分,min(sc.score) as 最低分,avg(sc.score) as 平均分,count(sc.SId) as 选修人数,sum(case when sc.score&gt;=60 then 1 else 0 end )/count(*)as 及格率,sum(case when sc.score&gt;=70 and sc.score&lt;80 then 1 else 0 end )/count(*)as 中等率,sum(case when sc.score&gt;=80 and sc.score&lt;90 then 1 else 0 end )/count(*)as 优良率,sum(case when sc.score&gt;=90 then 1 else 0 end )/count(*)as 优秀率,sum(case when sc.score = 100 THEN 1 else 0 end)/count(*) as 满分率From sc,course WHERE course.CId = sc.CId GROUP BY sc.CId ORDER BY count(*)DESC, sc.CId ASC; 按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺。 123SELECT sc1.CId,sc1.SId,sc1.score From sc sc1 GROUP BY sc1.CId,sc1.SId,sc1.score ORDER BY sc1.CId;SELECT sc1.CId,sc1.SId,sc1.score,COUNT(sc2.score)+1 as rank From sc sc1 LEFT JOIN sc sc2 On (sc1.CId = sc2.CId And sc1.score &lt; sc2.score)GROUP BY sc1.CId,sc1.SId,sc1.score ORDER BY sc1.CId,rank ASC; 按各科成绩进行排序，并显示排名， Score 重复时合并名次。 1SELECT sc1.CId,sc1.SId,sc1.score,COUNT(DISTINCT sc2.score)+1 as rank From sc sc1 LEFT JOIN sc sc2 On (sc1.CId = sc2.CId And sc1.score &lt; sc2.score)GROUP BY sc1.CId,sc1.SId,sc1.score ORDER BY sc1.CId,rank ASC; 查询学生的总成绩，并进行排名，总分重复时保留名次空缺。 12345set @crank=0;select q.sid, total, @crank := @crank +1 as rank from(select sc.sid, sum(sc.score) as total from scgroup by sc.sidorder by total desc)q; 查询学生的总成绩，并进行排名，总分重复时不保留名次空缺。 统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比。 12345678select course.cname, course.cid,sum(case when sc.score&lt;=100 and sc.score&gt;85 then 1 else 0 end) as \"[100-85]\",sum(case when sc.score&lt;=85 and sc.score&gt;70 then 1 else 0 end) as \"[85-70]\",sum(case when sc.score&lt;=70 and sc.score&gt;60 then 1 else 0 end) as \"[70-60]\",sum(case when sc.score&lt;=60 and sc.score&gt;0 then 1 else 0 end) as \"[60-0]\"from sc left join courseon sc.cid = course.cidgroup by sc.cid; 查询各科成绩前三名的记录。 123select * from sc where (select count(*) from sc as a where sc.cid = a.cid and sc.score&lt;a.score)&lt; 3 order by cid asc, sc.score desc;//比自己分数大的记录select a.sid,a.cid,a.score from sc a left join sc b on (a.cid = b.cid and a.score&lt;b.score) group by a.cid,a.sid having count(b.cid)&lt;3 order by a.cid ASC,a.score DESC;//自交查询比自身大的 查询每门课程被选修的学生数。 123SELECT course.*,COUNT(sc.SId) From course JOIN sc On sc.CId = course.CId GROUP BY sc.CId;select cid, count(sid) from sc group by cid; 查询出只选修两门课程的学生学号和姓名。 123SELECT st.* From student st JOIN sc On sc.SId = st.SId GROUP BY sc.SId HAVING(COUNT(sc.CId) = 2);select student.sid, student.sname from student where student.sid in(select sc.sid from sc group by sc.sid having count(sc.cid)=2); 查询男生、女生人数。 1SELECT COUNT(SId),(case WHEN Ssex = '男' THEN '男生' else '女生' end) as 性别 From student GROUP BY Ssex; 查询名字中含有「风」字的学生信息。 1SELECT * From student WHERE Sname like '%风%'; 查询同名同性学生名单，并统计同名人数。 123SELECT COUNT(st1.SId) as st1Count,st1.* From student st1 LEFT JOIN student st2 On (st1.Sname = st2.Sname And st1.Ssex = st2.Ssex ) GROUP BY st1.SId HAVING st1Count &gt; 1;select * from student where sname in (select sname from student group by sname having count(*)&gt;1); 查询 1990 年出生的学生名单。 1SELECT * From student WHERE YEAR(Sage) = 1990; 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列。 123SELECT course.*,avg(sc.score) as avgScore From course JOIN sc On sc.CId = course.CId GROUP BY sc.CId ORDER BY avgScore DESC,course.CId ASC;SELECT course.*,avg(sc.score) as avgScore From course,sc WHERE sc.CId = course.CId GROUP BY sc.CId ORDER BY avgScore DESC,course.CId ASC; 查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩。 1SELECT st.*,AVG(sc.score) as avgScore From student st,sc WHERE st.SId = sc.SId GROUP BY st.SId HAVING avgScore &gt; 85; 查询课程名称为「数学」，且分数低于 60 的学生姓名和分数。 1SELECT student.* From student,sc,course WHERE sc.CId = course.CId And student.SId = sc.SId And course.Cname ='数学' And sc.score &lt; 60; 查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）。 1select student.sname, cid, score from student left join sc on student.sid = sc.sid; 查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数。 1SELECT student.Sname,course.Cname,sc.score From sc,student,course WHERE sc.SId = student.SId And sc.CId = course.CId And sc.score &gt; 70; 查询存在不及格的课程 12345SELECT * From course WHERE cid in (SELECT sc.cid From sc WHERE sc.CId = CId And sc.score &lt; 60); SELECT * From course WHERE EXISTS (SELECT sc.* From sc WHERE sc.CId = course.CId And sc.score &lt; 60); SELECT sc.cid From sc WHERE sc.CId = CId And sc.score &lt; 60 ; 查询课程编号为 01 且课程成绩在 80 分及以上的学生的学号和姓名 。 1SELECT student.* From student,sc WHERE student.SId = sc.SId And sc.CId = '01' And sc.score &gt;= 80; 求每门课程的学生人数。 1select sc.CId,count(*) as 学生人数 from sc GROUP BY sc.CId; 成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩。 123select student.*, sc.score, sc.cid from student, teacher, course,sc where teacher.tid = course.tid and sc.sid = student.sid and sc.cid = course.cid and teacher.tname = \"张三\" having max(sc.score);select student.*, sc.score, sc.cid from student, teacher, course,sc where teacher.tid = course.tid and sc.sid = student.sid and sc.cid = course.cid and teacher.tname = \"张三\" order by score desc limit 1; 成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩。 12345678910111213select student.*, sc.score, sc.cid from student, teacher, course,sc where teacher.tid = course.tidand sc.sid = student.sidand sc.cid = course.cidand teacher.tname = \"张三\"and sc.score = ( select Max(sc.score) from sc,student, teacher, course where teacher.tid = course.tid and sc.sid = student.sid and sc.cid = course.cid and teacher.tname = \"张三\"); 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩。 123SELECT sc1.* From sc sc1 WHERE sc1.score =All (SELECT sc2.score From sc sc2 WHERE sc2.Sid = sc1.SId And sc1.CId != sc2.cid);select a.cid, a.sid,a.score from sc as a join sc as b on a.sid = b.sid and a.cid != b.cid and a.score = b.score group by cid, sid; 查询每门功成绩最好的前两名。 1select a.sid,a.cid,a.score from sc as a left join sc as b on a.cid = b.cid and a.score&lt;b.score group by a.cid, a.sid having count(b.cid)&lt;2 order by a.cid; 统计每门课程的学生选修人数（超过 5 人的课程才统计）。 1SELECT count(sid) as c,sc.CId From sc GROUP BY CId HAVING c &gt;= 5; 检索至少选修两门课程的学生学号。 1SELECT sid,count(cid) From sc GROUP BY SId HAVING count(cid) &gt;= 2; 查询选修了全部课程的学生信息。 1select student.* from sc ,student where sc.SId=student.SId GROUP BY sc.SId HAVING count(*) = (select DISTINCT count(*) from course);//括号很重要 查询各学生的年龄，只按年份来算。 1SELECT student.*,YEAR(NOW()) - YEAR(Sage) as age From student; 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一。 1select student.SId as 学生编号,student.Sname as 学生姓名,TIMESTAMPDIFF(YEAR,student.Sage,CURDATE()) as 学生年龄from student; 查询本周过生日的学生。 1select * from student where WEEKOFYEAR(student.Sage)=WEEKOFYEAR(CURDATE()); 查询下周过生日的学生。 1select * from student where WEEKOFYEAR(student.Sage)=WEEKOFYEAR(CURDATE())+1; 查询本月过生日的学生。 1select * from student where MONTH(student.Sage)=MONTH(CURDATE())+1; 查询下月过生日的学生。 1select * from student where MONTH(student.Sage)=MONTH(CURDATE())+1; Count count(1)是聚索引 count(),自动会优化指定到那一个字段 ，用count(),sql会帮你完成优化的 count()将返回表格中所有存在的行的总数*包括值为null的行 count(列名)将返回表格中除去null以外的所有行的总数(有默认值的列也会被计入） Where、Having WHERE语句在GROUP BY语句之前；SQL会在分组之前计算WHERE语句。 HAVING语句在GROUP BY语句之后；SQL会在分组之后计算HAVING语句。 All、Any、Some(&lt;&gt; 等同于!=) .. &gt;ALL 父查询中的结果集大于子查询中每一个结果集中的值,则为真 .. &gt;ANY,SOME 父查询中的结果集大于子查询中任意一个结果集中的值,则为真 .. =ANY 与子查询IN相同 .. &lt;&gt;ANY OR作用，父查询中的结果集不等于子查询中的a或者b或者c,则为真 .. NOT IN AND作用，父查询中的结果集不等于子查询中任意一个结果集中的值,则为真 In、Not In、Exists、Not Exists In的时候，会把子句中的查询作为结果缓存下来，然后对主查询中的每个记录进行查询。 Exists的时候，不在对子查询的结果进行缓存，子查询的返回的结果并不重要。使用exists的时候，我们使先对主查询进行查询，然后根据子查询的结果是否为真来决定是否返回。 子查询表大的用Exists，子查询表小的用In。 12SELECT * From rel WHERE rel.id NOT IN (SELECT rel_id FROM item );SELECT * From rel WHERE NOT EXISTS (SELECT item.id From item WHERE item.rel_id = rel.id); UNION、UNION ALL UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 Like ‘A_Z’: 所有以 ‘A’ 起头，另一个任何值的字原，且以 ‘Z’ 为结尾的字串。 ‘ABZ’ 和 ‘A2Z’ 都符合这一个模式，而 ‘AKKZ’ 并不符合 (因为在 A 和 Z 之间有两个字原，而不是一个字原)。 ‘ABC%’: 所有以 ‘ABC’ 起头的字串。举例来说，’ABCD’ 和 ‘ABCABC’ 都符合这个套式。 ‘%XYZ’: 所有以 ‘XYZ’ 结尾的字串。举例来说，’WXYZ’ 和 ‘ZZXYZ’ 都符合这个套式。 ‘%AN%’: 所有含有 ‘AN’ 这个套式的字串。举例来说， ‘LOS ANGELES’ 和 ‘SAN FRANCISCO’ 都符合这个套式。 TIMESTAMPDIFF 、TIMESTAMPADD TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2) ：返回日期或日期时间表达式datetime_expr1 和datetime_expr2the 之间的整数差。其结果的单位由interval 参数给出。该参数必须是以下值的其中一个 。 TIMESTAMPADD(interval,int_expr,datetime_expr) ：将整型表达式int_expr 添加到日期或日期时间表达式 datetime_expr中。式中的interval和上文中列举的取值是一样的。 参数 FRAC_SECOND。表示间隔是毫秒 SECOND。秒 MINUTE。分钟 HOUR。小时 DAY。天 WEEK。星期 MONTH。月 QUARTER。季度 YEAR。年 变量 SQL里面变量用@来标识 。 group by以后的查询结果无法使用别名。 CURDATE() 函数返回当前的日期。 WEEKOFYEAR() 返回日期用数字表示的范围是从1到53的日历周。WEEKOFYEAR()是一个兼容性函数，它等效于WEEK(date,3)。","categories":[{"name":"SQL","slug":"SQL","permalink":"https://batuer.github.io/categories/SQL/"}],"tags":[{"name":"Sql","slug":"Sql","permalink":"https://batuer.github.io/tags/Sql/"}]},{"title":"RecyclerView与ListView","slug":"RecyclerView&ListView","date":"2018-12-18T13:34:39.087Z","updated":"2018-12-18T13:34:39.087Z","comments":true,"path":"2018/12/18/RecyclerView&ListView/","link":"","permalink":"https://batuer.github.io/2018/12/18/RecyclerView&ListView/","excerpt":"","text":"区别布局效果对比 ListView布局单一，纵向。 RecyclerView的布局由LayoutManager决定（可纵向、横向、瀑布流或自定义）。 常用功能与API对比 HeaderView和Foot而View：ListView支持添加HeaderView和FooterView，RecyclerView没有。 EmptyView：ListView默认有setEmptyView()，RecyclerView没有。 局部刷新：RecyclerView支持局部刷新，ListView需自己实现。 123456789101112/** * @param data * @param pos 数据pos */ private void updateItemView(String data, int pos) &#123; int firstVisiblePosition = mLv.getFirstVisiblePosition(); int index = pos - firstVisiblePosition; if (index &gt;= 0 &amp;&amp; index &lt; mLv.getChildCount()) &#123; View child = mLv.getChildAt(index); //更新 &#125; &#125; 监听条目点击：ListView支持条目点击事件，RecyclerView需要自己实现，（RecyclerView无法添加onItemClickListener最佳的高效解决方案）。 动画效果：RecyclerView由默认实现效果可扩展性强。 Android L引入嵌套滚动机制（NestedScrolling） 在事件分发机制中，Touch事件在进行分发的时候，由父View向子View传递，一旦子View消费这个事件的话，那么接下来的事件分发的时候，父View将不接受，由子View进行处理；但是与Android的事件分发机制不同，嵌套滚动机制（Nested Scrolling）可以弥补这个不足，能让子View与父View同时处理这个Touch事件，主要实现在于NestedScrollingChild与NestedScrollingParent这两个接口；而在RecyclerView中，实现的是NestedScrollingChild，所以能实现嵌套滚动机制； ListView就没有实现嵌套滚动机制； RecyclerView优缺点优点 RecyclerView本身它是不关心视图相关的问题的 ，由LayoutManager管理。 只负责回收和重用的工作 。 可扩展性强。 缺点 条目监听。 HeaderView和FooterView。 EmptyView。 RecyclerView Adapter：包装数据集合并为每个条目创建视图。 ViewHolder：保存用于显示每个数据条目的 子View。 LayoutManager：决定每个ItemView的位置。 ItemDecoration：条目间隔绘制。 ItemAnimatior：条目添加、移除、重排序动画。 ListVIew与RecyclerView缓存机制对比 https://segmentfault.com/a/1190000007331249 缓存原理相似 回收离屏的ItemView至缓存。 入屏的ItemView优先从缓存中获取。 两者实现细节有差异。 缓存层级不同RecyclerView mAttachedScrap 快速重用屏幕上可见的列表项ItemView，不需要createView()和bindView()。 mCacheViews（优势） 缓存离开屏幕的 ItemView，复用。 默认上限2，即缓存屏幕外2个ItemView。 ItemView被复用时，无需bindView快速复用。 Adapter被更换时被清空，生命周期关联于Adapter。 mViewCacheExtension 默认不实现，扩展。 mRecyclerPool 缓存离开屏幕的 ItemView，复用。 默认上限5。 ListView mActiveViews 快速重用屏幕上可见的列表项ItemView，不需要createView()和bindView()。 mScrapViews 缓存离开屏幕的ItemView，复用。 Adapter被更换时，被清空，生命周期关联于Adapter。 缓存不同 RecyclerView缓存RecyclerView.ViewHolder，ItemView + ViewHolder。 ListView获取缓存 RecyclerView获取缓存 局部刷新 RecyclerView 提供局部刷新，ListVIew没有。 RecyclerView局部刷新时，会预先通过对pso和flag的预处理，尽可能的减少bindVIew()。 结论 性能上，RecyclerView并没有显著的提升。 有频繁更新、ItemView动画、局部刷新这些需求时，RecyclerView优势大于ListView。 RecyclerView扩展性强（LayoutManager：ItemView布局，ViewCacheExtension：ItemView缓存复用 ）。","categories":[{"name":"RecyclerView、ListView","slug":"RecyclerView、ListView","permalink":"https://batuer.github.io/categories/RecyclerView、ListView/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://batuer.github.io/tags/RecyclerView/"},{"name":"ListView","slug":"ListView","permalink":"https://batuer.github.io/tags/ListView/"}]},{"title":"设计模式六大原则","slug":"OOD_Patterns","date":"2018-12-18T13:34:39.087Z","updated":"2018-12-18T13:34:39.087Z","comments":true,"path":"2018/12/18/OOD_Patterns/","link":"","permalink":"https://batuer.github.io/2018/12/18/OOD_Patterns/","excerpt":"","text":"单一职责原则定义一个类只做一件事。 优点 类的复杂性降低，职责清晰。 可读性、可维护性提高。 变更风险降低，变更是必然的。遵守单一职责，修改一个功能时，显著降低对其它功能的影响。 里氏替换原则面向对象三大特点：继承、多态、封装，里氏替换原则就是依赖于继承、多态这两大特性。 定义只要父类能出现的地方子类就可以替换，并且替换为子类也不会差生任何错误和异常。 优点 代码共享，减少创建类的工作量，每个字类都拥有父类非私有的方法和属性。 代码重用性。 代码扩展性，继承父类方法具体子类实现。 缺点 继承是侵入性的，只要继承就必须拥有父类的非私有属性和方法。 降低代码灵活性，子类必须拥有父类属性和方法，子类有约束。 增强耦合性，父类的属性和方法修改时，需要考虑子类的实现。 依赖倒置原则定义 高层模块不应该依赖底层模块，两者都应该依赖其抽象。 抽象不应该依赖细节。 细节应该依赖抽象。 优点 可扩展性好。 耦合度低。 注意 底层模块尽量都要有抽象类或接口，或者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 开闭原则定义一个软件实体如类、模块和函数都应该对扩展开放，对修改关闭。 优点 增加灵活性。 可扩展性高。 接口隔离原则定义 一个类对另一个类的依赖应该建立在最小接口上。 不依赖不需要的接口。 接口细化。 注意 接口细化，但要有限度，避免接口数量过多，设计复杂化。 提高内聚，减少对外交互。 迪米特法则（最少知识原则）定义一个对象应该对其他对象最少的了解。 优点 降低复杂度。 增加稳定性。 高内聚低耦合，结构清晰。 面向对象六大原则最关键在于：抽象、单一职责、最小化。","categories":[{"name":"设计原则","slug":"设计原则","permalink":"https://batuer.github.io/categories/设计原则/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://batuer.github.io/tags/设计模式/"}]},{"title":"Java多线程","slug":"JavaThread","date":"2018-12-18T13:34:39.086Z","updated":"2018-12-18T13:34:39.086Z","comments":true,"path":"2018/12/18/JavaThread/","link":"","permalink":"https://batuer.github.io/2018/12/18/JavaThread/","excerpt":"","text":"Synchronized 内置锁，互斥性。 JVM关键字，修饰符。 内置条件队列操作接口Object.waie()、notify()、notifyAll()。 ReentrantLock 默认非公平锁。 内置锁类似功能。 公平锁：等待时间最长的会最先被唤醒获取锁 。 重入锁：线程可以重复获取已经持有的锁。 Synchronized中，所有的线程都在同一个object的条件队列上等待。而ReentrantLock中，每个condition都维护了一个条件队列。 每一个Lock可以有任意数据的Condition对象，Condition是与Lock绑定的，所以就有Lock的公平性特性：如果是公平锁，线程为按照FIFO的顺序从Condition.await中释放，如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。 Condition接口定义的方法，await对应于Object.wait，signal对应于Object.notify，signalAll对应于Object.notifyAll。特别说明的是Condition的接口改变名称就是为了避免与Object中的wait/notify/notifyAll的语义和使用上混淆。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*** ReentrantLock 的使用*/public class Queue&lt;T&gt; &#123; private final T[] mItems; private final Lock mLock = new ReentrantLock(); private Condition mNotFull = mLock.newCondition(); private Condition mNotEmpty = mLock.newCondition(); private int head, tail, count; public Queue(int maxSize) &#123; mItems = (T[]) new Object[maxSize]; &#125; public Queue() &#123; this(10); &#125; public void put(T t) throws InterruptedException &#123; mLock.lock();//获取锁 try &#123; while (count == mItems.length) &#123; //数组满时，线程进入等待队列挂起。线程被唤醒时，从这里返回。 mNotFull.await(); &#125; mItems[tail] = t; if (++tail == mItems.length) &#123; tail = 0; &#125; ++count; mNotEmpty.signal(); &#125; finally &#123; mLock.unlock(); &#125; &#125; public T take() throws InterruptedException &#123; mLock.lock(); try &#123; while (count == 0) &#123; mNotEmpty.await(); &#125; T o = mItems[head]; mItems[head] = null;//GC if (++head == mItems.length) &#123; head = 0; &#125; --count; mNotFull.signal(); return o; &#125; finally &#123; mLock.unlock(); &#125; &#125;&#125; Volatile 内存可见性。 放置指令重排。 Semaphore 信号量，跟锁机制存在一定的相似性。 Semaphore也是一种锁机制。 ReentrantLock是只允许一个线程获得锁。 Semaphore允许多个线程同时获得执行许可。 12345678910111213141516171819private static void semaphore() &#123; final Semaphore semaphore = new Semaphore(5); for (int i = 0; i &lt; 20; i++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; semaphore.acquire(); Thread.sleep(3000); semaphore.release(); System.err.println(Thread.currentThread().getName() + \":\" + new Date()); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;); thread.setName(\"Thread:\" + i); thread.start(); &#125; &#125; CountDownLatch 一个线程等其它一个或多个线程。 计数器实现，一个线程完成任务计数器减1. 12345678910111213141516171819202122232425262728293031323334353637private static void countDownLatch() &#123; final CountDownLatch countDownLatch = new CountDownLatch(5); for (int i = 0; i &lt; 5; i++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(Thread.currentThread() .getName() + \":\" + System.currentTimeMillis()); countDownLatch.countDown(); &#125; catch (InterruptedException e) &#123; System.out.println(e.toString()); &#125; &#125; &#125;); thread.setName(\"Thread:--:\" + i); thread.start(); &#125; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.err.println(countDownLatch.getCount() + \"start---------\" + System .currentTimeMillis()); countDownLatch.await(); System.err.println(\"end-----------\" + countDownLatch.getCount()); &#125; catch (InterruptedException e) &#123; System.err.println(e.toString()); &#125; &#125; &#125;); thread1.setName(\"Main Thread:\"); thread1.start();&#125; CyclicBarrier 所有线程必须同时到达栅栏位置才能继续执行下一步操作。 可以循环使用。 123456789101112131415161718192021222324private static void cyclicBarrier() &#123; final CyclicBarrier barrier = new CyclicBarrier(5, new Runnable() &#123; @Override public void run() &#123; System.out.println(\"All Over\"); &#125; &#125;); for (int i = 0; i &lt; 5; i++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + \"over\"); barrier.await(); &#125; catch (Exception e) &#123; System.out.println(e.toString()); &#125; &#125; &#125;); thread.setName(\"Thread:\" + i); thread.start(); &#125; &#125; ReadWriteLock 数据读写，保证数据的一致性和完整性。 读和写是互斥的。 写和写是互斥的。 读和读不是互斥的。 12345678910111213141516171819202122232425public class Data &#123; private Long value; private ReadWriteLock mReadWriteLock = new ReentrantReadWriteLock(); public Long getValue() &#123; Lock readLock = mReadWriteLock.readLock(); try &#123; readLock.lock(); return value; &#125; finally &#123; readLock.unlock(); &#125; &#125; public void setValue(Long value) &#123; Lock writeLock = mReadWriteLock.writeLock(); try &#123; writeLock.lock(); this.value = value; &#125; finally &#123; writeLock.unlock(); &#125; &#125;&#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"https://batuer.github.io/categories/多线程/"}],"tags":[{"name":"Synchronized","slug":"Synchronized","permalink":"https://batuer.github.io/tags/Synchronized/"},{"name":"ReentrantLock","slug":"ReentrantLock","permalink":"https://batuer.github.io/tags/ReentrantLock/"},{"name":"Volitale","slug":"Volitale","permalink":"https://batuer.github.io/tags/Volitale/"},{"name":"Semaphore","slug":"Semaphore","permalink":"https://batuer.github.io/tags/Semaphore/"},{"name":"CountDownLatch","slug":"CountDownLatch","permalink":"https://batuer.github.io/tags/CountDownLatch/"},{"name":"CyclicBarrier","slug":"CyclicBarrier","permalink":"https://batuer.github.io/tags/CyclicBarrier/"}]},{"title":"Java内存","slug":"JavaMemory","date":"2018-12-18T13:34:39.085Z","updated":"2018-12-18T13:34:39.085Z","comments":true,"path":"2018/12/18/JavaMemory/","link":"","permalink":"https://batuer.github.io/2018/12/18/JavaMemory/","excerpt":"","text":"Java内存区域 程序计数器： 较小的内存空间。 当前线程锁执行的字节码行号指示器。 下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程回复等基本功能都依赖于计数器。 虚拟机栈： 线程私有，生命周期与线程相同。 每个方法执行的时候都会同时创建一个栈帧用于存储局部变量表、操作站、动态链接、方法出口等信息。 每个方法调用到执行完成，就想对应着一个栈帧在虚拟机中从入栈到出栈的过程。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError。 如果虚拟机栈扩展无法申请足够内存时会抛出OutOfMemoryError。 本地方法栈： 与虚拟机栈作用相似。 区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为Native方法服务。 堆： Java虚拟机中所管理内存中最大的一块。 所有线程共享，虚拟机启动时创建。 存放对象实例。 Java堆有划分成好几个区域。 内存不够时会抛出OutOfMemoryError。 方法区： 线程共享。 包含所有class和static变量。 运行时常量池都分配在Java虚拟机的方法区之中。 Java内存模型(Java Memory Model,JMM) 一种抽象概念，并不真实存在，描述的是一组规范。定义程序中各个变量的访问方式。 JMM可以屏蔽各种硬件和操作系统的访问差异，实现Java程序在各种平台下能达到一致的内存访问效果。 由于JVM(Java Virtual Machine)运行程序的实体是线程，每个线程创建时JVM都会为其创建一个栈空间，用于存储线程私有数据。 Java内存模型规定所有变量都存储于在主内存中，主内存是共享区域，线程对变量的操作必须在工作内存中进行。 主内存：所有线程创建的实例对象都存放在主内存中，不论是成员变量还是局部变量，由于是共享区域，所以涉及线程安全问题。 工作内存：存储当前方法的所有变量信息（主内存中的副本），线程间不可互相访问工作内存。 主内存的实例对象可以被多线程共享，拷贝副本到自己线程进行操作，执行操作完成刷新到主内存中。 JMM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见，这组规则也称为Java内存模型(即JMM)，JMM是围绕着程序执行的原子性。有序性、可见性展开的。 原子性：一个操作不可终端，即使在多线程环境下，一个操作不会受其他线程影响。 有序性(指令重排)：为了提高性能编译器和处理器常常会指令做重排。 编译器优化重排：重新安排语句的执行顺序并不严格按照代码顺序执行。 处理器重排：内存系统的重排，缓存的读写同步。 可见性：当某一线程修改了某个共享变量的值，其他线程能否马上得知这个修改的值。 JM们的解决方案： 基本数据类型读写操作具有原子性。 Synchronized关键字和重入锁(ReentrantLock)保证程序执行的原子性。 volatile关键字 精致重拍优化。 某一线程修改了volatile修饰的关键字，其他线程会马上得知修改值。 JMM中的happens-before原则： 程序顺序原则：一个线程内，代码顺序执行。 传递性。 锁规则：解锁操作必然在后续的同一个锁的加锁之前，有对应加锁解锁。 volatile规则：volatile修改前必然先读主内存。 线程启动规则：线程的start()方法先于它的每一个动作。 线程终端规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。 线程终止规则：线程的所有操作先于线程的终结。 对象终结规则：对象的构造函数执行，结束先于finalize()方法。 JMM就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before原则）及其外部可使用的同步手段(synchronized/volatile等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/tags/Java/"}]},{"title":"Java反射","slug":"JavaReflect","date":"2018-12-18T13:34:39.085Z","updated":"2018-12-18T13:34:39.085Z","comments":true,"path":"2018/12/18/JavaReflect/","link":"","permalink":"https://batuer.github.io/2018/12/18/JavaReflect/","excerpt":"","text":"一、概述Java反射机制定义 Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java 反射机制的功能 1.在运行时判断任意一个对象所属的类。 2.在运行时构造任意一个类的对象。 3.在运行时判断任意一个类所具有的成员变量和方法。 4.在运行时调用任意一个对象的方法。 5.生成动态代理。 Java 反射机制的应用场景 1.逆向代码 ，例如反编译 2.与注解相结合的框架 例如Retrofit 3.单纯的反射机制应用框架 例如EventBus 4.动态生成类框架 例如Gson 二、代理模式定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。 1、代理模式的参与者代理模式的角色分四种： 主题接口：Subject 是委托对象和代理对象都共同实现的接口，即代理类的所实现的行为接口。Request() 是委托对象和代理对象共同拥有的方法。目标对象：ReaSubject 是原对象，也就是被代理的对象。代理对象：Proxy 是代理对象，用来封装真是主题类的代理类。客户端 ：使用代理类和主题接口完成一些工作。 2、代理模式的分类代理的实现分为： 静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。 3、代理模式的实现思路1.代理对象和目标对象均实现同一个行为接口。 2.代理类和目标类分别具体实现接口逻辑。 3.在代理类的构造函数中实例化一个目标对象。 4.在代理类中调用目标对象的行为接口。 5.客户端想要调用目标对象的行为接口，只能通过代理类来操作。 4、静态代理模式的简单实现1234567891011121314151617181920212223242526272829303132public class ProxyDemo &#123; public static void main(String args[]) &#123; ShopCart subject = new ShopCart(); ShopProxy p = new ShopProxy(subject); p.shop(); &#125; &#125; interface Shop &#123; void shop(); &#125; class ShopCart implements Shop &#123; @Override public void shop() &#123; Log.w(\"Fire\", \"ShopCart:25: Shop\"); &#125; &#125; class ShopProxy implements Shop &#123; private ShopCart mShopCart; public ShopProxy(ShopCart shopCart) &#123; mShopCart = shopCart; &#125; @Override public void shop() &#123; Log.w(\"Fire\", \"ShopProxy:38:登录验证\"); mShopCart.shop(); Log.w(\"Fire\", \"ShopProxy:40:日志记录\"); &#125; &#125; 目标对象(RealSubject )以及代理对象（Proxy）都实现了主题接口（Subject）。在代理对象（Proxy）中，通过构造函数传入目标对象(RealSubject )，然后重写主题接口（Subject）的request()方法，在该方法中调用目标对象(RealSubject )的request()方法，并可以添加一些额外的处理工作在目标对象(RealSubject )的request()方法的前后。 代理模式的好处： 假如有这样的需求，要在某些模块方法调用前后加上一些统一的前后处理操作，比如在添加购物车、修改订单等操作前后统一加上登陆验证与日志记录处理，该怎样实现？首先想到最简单的就是直接修改源码，在对应模块的对应方法前后添加操作。如果模块很多，你会发现，修改源码不仅非常麻烦、难以维护，而且会使代码显得十分臃肿。 这时候就轮到代理模式上场了，它可以在被调用方法前后加上自己的操作，而不需要更改被调用类的源码，大大地降低了模块之间的耦合性，体现了极大的优势。 三、Java反射机制与动态代理1、动态代理介绍动态代理是指在运行时动态生成代理类。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。与静态处理类相比，动态类有诸多好处。 ①不需要为(RealSubject )写一个形式上完全一样的封装类，假如主题接口（Subject）中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则目标对象和代理类都要修改，不利于系统维护； ②使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。 2、动态代理涉及的主要类java.lang.reflect.Proxy:这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。Proxy提供了用户创建动态代理类和代理对象的静态方法，它是所有动态代理类的父类。 java.lang.reflect.InvocationHandler:这里称他为”调用处理器”，它是一个接口。当调用动态代理类中的方法时，将会直接转接到执行自定义的InvocationHandler中的invoke()方法。即我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口，通过重写invoke()方法来执行具体内容。 Proxy提供了如下两个方法来创建动态代理类和动态代理实例。 static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces) 返回代理类的java.lang.Class对象。第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么），该代理类将实现interfaces所指定的所有接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法。 static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 返回代理类实例。参数与上述方法一致。 对应上述两种方法创建动态代理对象的方式： 12345678//创建一个InvocationHandler对象InvocationHandler handler = new MyInvocationHandler(.args..);//使用Proxy生成一个动态代理类Class proxyClass = Proxy.getProxyClass(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces());//获取proxyClass类中一个带InvocationHandler参数的构造器Constructor constructor = proxyClass.getConstructor(InvocationHandler.class);//调用constructor的newInstance方法来创建动态实例RealSubject real = (RealSubject)constructor.newInstance(handler); 123456 //创建一个InvocationHandler对象InvocationHandler handler = new MyInvocationHandler();//使用Proxy直接生成一个动态代理对象RealSubject real = (RealSubject) java.lang.reflect.Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler); newProxyInstance这个方法实际上做了两件事：第一，创建了一个新的类【代理类】，这个类实现了Class[] interfaces中的所有接口，并通过你指定的ClassLoader将生成的类的字节码加载到JVM中，创建Class对象；第二，以你传入的InvocationHandler作为参数创建一个代理类的实例并返回。 Proxy 类还有一些静态方法，比如： InvocationHandler getInvocationHandler(Object proxy):获得代理对象对应的调用处理器对象。 Class getProxyClass(ClassLoader loader, Class[] interfaces):根据类加载器和实现的接口获得代理类。 InvocationHandler 接口中有方法： invoke(Object proxy, Method method, Object[] args)这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。 3、动态代理模式的简单实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * Created by Administrator on 2018/2/17. */public class DynamicProxyDemo &#123; public static void main(String[] args) &#123; //1.创建目标对象 RealSubject realSubject = new RealSubject(); //2.创建调用处理器对象 ProxyHandler handler = new ProxyHandler(realSubject); //3.动态生成代理对象 Subject proxySubject = (Subject) Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler); //4.通过代理对象调用方法 proxySubject.request(); &#125;&#125;/** * 主题接口 */interface Subject &#123; void request();&#125;/** * 目标对象类 */class RealSubject implements Subject &#123; public void request() &#123; System.out.println(\"====RealSubject Request====\"); &#125;&#125;/** * 代理类的调用处理器 */class ProxyHandler implements InvocationHandler &#123; private Subject subject; public ProxyHandler(Subject subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作 System.out.println(\"====before====\"); //调用RealSubject中的方法 Object result = method.invoke(subject, args); System.out.println(\"====after====\"); return result; &#125;&#125; 可以看到，我们通过newProxyInstance就产生了一个Subject 的实例，即代理类的实例，然后就可以通过Subject .request()，就会调用InvocationHandler中的invoke()方法，传入方法Method对象，以及调用方法的参数，通过Method.invoke调用RealSubject中的方法的request()方法。同时可以在InvocationHandler中的invoke()方法加入其他执行逻辑。 四、泛型和Class类从JDK 1.5 后，Java中引入泛型机制，Class类也增加了泛型功能，从而允许使用泛型来限制Class类，例如：String.class的类型实际上是Class&lt;String&gt;。如果Class对应的类暂时未知，则使用Class&lt;?&gt;(?是通配符)。通过反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。 泛型的好处众多，最主要的一点就是避免类型转换，防止出现ClassCastException，即类型转换异常。 五、使用反射来获取泛型信息通过指定类对应的 Class 对象，可以获得该类里包含的所有 Field，不管该 Field 是使用 private 修饰，还是使用 public 修饰。获得了 Field 对象后，就可以很容易地获得该 Field 的数据类型，即使用如下代码即可获得指定 Field 的类型。 12// 获取 Field 对象 f 的类型Class&lt;?&gt; a = f.getType(); 但这种方式只对普通类型的 Field 有效。如果该 Field 的类型是有泛型限制的类型，如 Map&lt;String, Integer&gt; 类型，则不能准确地得到该 Field 的泛型参数。 为了获得指定 Field 的泛型类型，应先使用如下方法来获取指定 Field 的类型。 12// 获得 Field 实例的泛型类型Type type = f.getGenericType(); 然后将 Type 对象强制类型转换为 ParameterizedType 对象，ParameterizedType 代表被参数化的类型，也就是增加了泛型限制的类型。ParameterizedType 类提供了如下两个方法。 getRawType()：返回没有泛型信息的原始类型。 getActualTypeArguments()：返回泛型参数的类型。 下面是一个获取泛型类型的完整程序。 123456789101112131415161718192021222324252627282930313233343536public class GenericTest&#123; private Map&lt;String , Integer&gt; score; public static void main(String[] args) throws Exception &#123; Class&lt;GenericTest&gt; clazz = GenericTest.class; Field f = clazz.getDeclaredField(\"score\"); // 直接使用getType()取出Field类型只对普通类型的Field有效 Class&lt;?&gt; a = f.getType(); // 下面将看到仅输出java.util.Map System.out.println(\"score的类型是:\" + a); // 获得Field实例f的泛型类型 Type gType = f.getGenericType(); // 如果gType类型是ParameterizedType对象 if(gType instanceof ParameterizedType) &#123; // 强制类型转换 ParameterizedType pType = (ParameterizedType)gType; // 获取原始类型 Type rType = pType.getRawType(); System.out.println(\"原始类型是：\" + rType); // 取得泛型类型的泛型参数 Type[] tArgs = pType.getActualTypeArguments(); System.out.println(\"泛型类型是:\"); for (int i = 0; i &lt; tArgs.length; i++) &#123; System.out.println(\"第\" + i + \"个泛型类型是：\" + tArgs[i]); &#125; &#125; else &#123; System.out.println(\"获取泛型类型出错！\"); &#125; &#125;&#125; 输出结果： score 的类型是: interface java.util.Map原始类型是: interface java.util.Map泛型类型是:第 0 个泛型类型是: class java.lang.String第 1 个泛型类型是：class java.lang.Integer 从上面的运行结果可以看出，直接使用 Field 的 getType() 方法只能获取普通类型的 Field 的数据类型：对于增加了泛型参数的类型的 Field，应该使用 getGenericType() 方法来取得其类型。 Type 也是 java.lang.reflect 包下的一个接口，该接口代表所有类型的公共高级接口，Class 是 Type 接口的实现类。Type 包括原始类型、参数化类型、数组类型、类型变量和基本类型等。","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://batuer.github.io/tags/Java基础/"},{"name":"Java反射","slug":"Java反射","permalink":"https://batuer.github.io/tags/Java反射/"}]},{"title":"Java泛型","slug":"JavaGenericity","date":"2018-12-18T13:34:39.084Z","updated":"2018-12-18T13:34:39.084Z","comments":true,"path":"2018/12/18/JavaGenericity/","link":"","permalink":"https://batuer.github.io/2018/12/18/JavaGenericity/","excerpt":"","text":"一、泛型简介1.引入泛型的目的了解引入泛型的动机，就先从语法糖开始了解。 语法糖 语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。 泛型的目的： Java 泛型就是把一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现ClassCastException，即类型转换异常。 2.泛型初探JDK 1.5 时才增加了泛型，并在很大程度上都是方便集合的使用，使其能够记住其元素的数据类型。 3.泛型的好处①类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。 ②消除了代码中许多的强制类型转换，增强了代码的可读性。 ③为较大的优化带来了可能。 二、泛型的使用1.泛型类和泛型接口 这就是泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。 在JDK 1.7 增加了泛型的“菱形”语法：Java允许在构造器后不需要带完成的泛型信息，只要给出一对尖括号（&lt;&gt;）即可，Java可以推断尖括号里应该是什么泛型信息。 当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或者从该父类派生子类，需要注意：使用这些接口、父类派生子类时不能再包含类型形参，需要传入具体的类型。 2.泛型的方法 泛型类和泛型接口中提到，可以在泛型类、泛型接口的方法中，把泛型中声明的类型形参当成普通类型使用。 所谓泛型方法，就是在声明方法时定义一个或多个类型形参。 3.泛型构造器正如泛型方法允许在方法签名中声明类型形参一样，Java也允许在构造器签名中声明类型形参，这样就产生了所谓的泛型构造器。和使用普通泛型方法一样没区别，一种是显式指定泛型参数，另一种是隐式推断，如果是显式指定则以显式指定的类型参数为准，如果传入的参数的类型和指定的类型实参不符，将会编译报错。 三、类型通配符顾名思义就是匹配任意类型的类型实参。 类型通配符是一个问号（？)，将一个问号作为类型实参传给List集合，写作：List&lt;?&gt;（意思是元素类型未知的List）。这个问号（？）被成为通配符，它的元素类型可以匹配任何类型。 带限通配符简单来讲，使用通配符的目的是来限制泛型的类型参数的类型，使其满足某种条件，固定为某些类。 主要分为两类即：上限通配符和下限通配符。 1.上限通配符如果想限制使用泛型类别时，只能用某个特定类型或者是其子类型才能实例化该类型时，可以在定义类型时，使用extends关键字指定这个类型必须是继承某个类，或者实现某个接口，也可以是这个类或接口本身。 2.下限通配符如果想限制使用泛型类别时，只能用某个特定类型或者是其父类型才能实例化该类型时，可以在定义类型时，使用super关键字指定这个类型必须是是某个类的父类，或者是某个接口的父接口，也可以是这个类或接口本身。 四、类型擦除 不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://batuer.github.io/tags/Java基础/"},{"name":"Java泛型","slug":"Java泛型","permalink":"https://batuer.github.io/tags/Java泛型/"}]},{"title":"Java集合","slug":"JavaCollection","date":"2018-12-18T13:34:39.083Z","updated":"2018-12-18T13:34:39.083Z","comments":true,"path":"2018/12/18/JavaCollection/","link":"","permalink":"https://batuer.github.io/2018/12/18/JavaCollection/","excerpt":"","text":"一、Java集合类简介：Java集合大致可以分为Set、List、Queue和Map四种体系。 其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。Java 5 又增加了Queue体系集合，代表一种队列集合实现。 Java集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。从Java 5 增加了泛型以后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。 1.Java集合和数组的区别：①.数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。 ②.数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上只是保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。 2.Java集合类之间的继承关系:Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。 图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。 Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。 图中，HashMap，TreeMap是我们经常会用到的集合类。 二、Collection接口：1.简介Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。由于方法比较多，就偷个懒，直接把JDK文档上的内容搬过来。 1.1.接口中定义的方法 可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。其中重点介绍iterator()方法，该方法的返回值是Iterator。 1.2.使用Iterator遍历集合元素Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。Iterator接口中主要定义了2个方法： 下面程序简单示范了通过Iterator对象逐个获取元素的逻辑。123456789101112131415161718public class IteratorExample &#123; public static void main(String[] args)&#123; //创建集合，添加元素 Collection&lt;Day&gt; days = new ArrayList&lt;Day&gt;(); for(int i =0;i&lt;10;i++)&#123; Day day = new Day(i,i*60,i*3600); days.add(day); &#125; //获取days集合的迭代器 Iterator&lt;Day&gt; iterator = days.iterator(); while(iterator.hasNext())&#123;//判断是否有下一个元素 Day next = iterator.next();//取出该元素 //逐个遍历，取得元素后进行后续操作 ..... &#125; &#125;&#125; 注意： 当使用Iterator对集合元素进行迭代时，把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量。下面的程序演示了这一点：123456789101112131415161718192021222324252627282930public class IteratorExample &#123; public static void main(String[] args) &#123; List&lt;MyObject&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; list.add(new MyObject(i)); &#125; System.out.println(list.toString()); Iterator&lt;MyObject&gt; iterator = list.iterator();//集合元素的值传给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址 while (iterator.hasNext()) &#123; MyObject next = iterator.next(); next.num = 99; &#125; System.out.println(list.toString()); &#125; static class MyObject &#123; int num; MyObject(int num) &#123; this.num = num; &#125; @Override public String toString() &#123; return String.valueOf(num); &#125; &#125;&#125; 输出结果如下： [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [99, 99, 99, 99, 99, 99, 99, 99, 99, 99] 下面具体介绍Collection接口的三个子接口Set，List，Queue。 2.Set集合简介Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。 Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。 3.List集合3.1.简介List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为0，第二个添加的元素索引为1…… List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。 3.2.接口中定义的方法 void add(int index, Object element): 在列表的指定位置插入指定元素（可选操作）。 boolean addAll(int index, Collection&lt;? extends E&gt; c) : 将集合c 中的所有元素都插入到列表中的指定位置index处。 Object get(index): 返回列表中指定位置的元素。 int indexOf(Object o): 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 int lastIndexOf(Object o): 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 Object remove(int index): 移除列表中指定位置的元素。 Object set(int index, Object element): 用指定元素替换列表中指定位置的元素。 List subList(int fromIndex, int toIndex): 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的所有集合元素组成的子集。 Object[] toArray(): 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。 除此之外，Java 8还为List接口添加了如下两个默认方法。 void replaceAll(UnaryOperator operator): 根据operator指定的计算规则重新设置List集合的所有元素。 void sort(Comparator c): 根据Comparator参数对List集合的元素排序。 4.Queue集合4.1.简介Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。 4.2.接口中定义的方法 三、Map集合1.简介Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。 如下图所描述，key和value之间存在单向一对一关系，即通过指定的key,总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value。 2.Map集合与Set集合、List集合的关系①.与Set集合的关系 如果 把Map里的所有key放在一起看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个keySet()方法，用户返回Map里所有key组成的Set集合。 ②.与List集合的关系 如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。 3.接口中定义的方法 Map中还包括一个内部类Entry，该类封装了一个key-value对。Entry包含如下三个方法： Map集合最典型的用法就是成对地添加、删除key-value对，然后就是判断该Map中是否包含指定key，是否包含指定value，也可以通过Map提供的keySet()方法获取所有key组成的集合，然后使用foreach循环来遍历Map的所有key，根据key即可遍历所有的value。下面程序代码示范Map的一些基本功能： 1234567891011121314151617181920212223242526public class MapTest &#123; public static void main(String[] args)&#123; Day day1 = new Day(1, 2, 3); Day day2 = new Day(2, 3, 4); Map&lt;String,Day&gt; map = new HashMap&lt;String,Day&gt;(); //成对放入key-value对 map.put(\"第一个\", day1); map.put(\"第二个\", day2); //判断是否包含指定的key System.out.println(map.containsKey(\"第一个\")); //判断是否包含指定的value System.out.println(map.containsValue(day1)); //循环遍历 //1.获得Map中所有key组成的set集合 Set&lt;String&gt; keySet = map.keySet(); //2.使用foreach进行遍历 for (String key : keySet) &#123; //根据key获得指定的value System.out.println(map.get(key)); &#125; //根据key来移除key-value对 map.remove(\"第一个\"); System.out.println(map); &#125;&#125; 输出结果： true true Day [hour=2, minute=3, second=4] Day [hour=1, minute=2, second=3] {第二个=Day [hour=2, minute=3, second=4]} 四、e.g. 123456数组: 优点：使用方便 ，查询效率 比链表高，内存为一连续的区域 缺点：大小固定，不适合动态存储，不方便动态添加链表： 优点：可动态添加删除 大小可变 缺点：只能通过顺次指针访问，查询效率低 ArrayList: 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。 按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。 直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。 ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。 LinkedList: 以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。 按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。 插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add()，addFirst()，removeLast()或用iterator()上的remove()能省掉指针的移动。 LinkedList是一个简单的数据结构，与ArrayList不同的是，他是基于链表实现的。 set和get函数都调用了node函数，该函数会以O(n/2)的性能去获取一个节点。 判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n/2)。 HashMap:1. 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，不保证有序(比如插入的顺序)、也不保证序不随时间变。HashMap存储着Entry(hash, key, value, next)对象。 2. 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( (n-1) &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。 4. 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。 TreeMap: HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。 LinkedHashMap: LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。 保证双向链表中的节点次序或者双向链表容量所 总之，LinkedHashMap不愧是HashMap的儿子，和老子太像了，当然，青出于蓝而胜于蓝，LinkedHashMap的其他的操作也基本上都是为了维护好那个具有访问顺序的双向链表。 ArrayMap: ArrayMap的存储中没有Entry这个东西，他是由两个数组来维护的，mHashes数组中保存的是每一项的HashCode值，mArray中就是键值对，每两个元素代表一个键值对，前面保存key，后面的保存value。 HashMap内部有一个HashMapEntry[]对象，每一个键值对都存储在这个对象里，当使用put方法添加键值对时，就会new一个HashMapEntry对象，而ArrayMap的存储中没有Entry这个东西，他是由两个数组来维护的，mHashes数组中保存的是每一项的HashCode值，mArray中就是键值对，每两个元素代表一个键值对，前面保存key，后面的保存value。 ArrayMap 和 HashMap区别： 存储方式不同： HashMap内部有一个HashMapEntry[]对象，每一个键值对都存储在这个对象里，当使用put方法添加键值对时，就会new一个HashMapEntry对象。 ArrayMap的存储中没有Entry这个东西，他是由两个数组来维护的mHashes数组中保存的是每一项的HashCode值，mArray中就是键值对，每两个元素代表一个键值对，前面保存key，后面的保存value。 添加数据时扩容时的处理不一样： HashMap使用New的方式申请空间，并返回一个新的对象，开销会比较大。 ArrayMap用的是System.arrayCopy数据，所以效率相对要高。 ArrayMap提供了数组收缩的功能，只要判断过判断容量尺寸，例如clear，put，remove等方法，只要通过判断size大小触发到freeArrays或者allocArrays方法，会重新收缩数组，释放空间。 ArrayMap相比传统的HashMap速度要慢，因为查找方法是二分法，并且当你删除或者添加数据时，会对空间重新调整，在使用大量数据时，效率低于50%。可以说ArrayMap是牺牲了时间换区空间。但在写手机app时，适时的使用ArrayMap，会给内存使用带来可观的提升。ArrayMap内部还是按照正序排列的，这时因为ArrayMap在检索数据的时候使用的是二分查找，所以每次插入新数据的时候ArrayMap都需要重新排序，逆序是最差情况；","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://batuer.github.io/tags/Java基础/"},{"name":"Java集合","slug":"Java集合","permalink":"https://batuer.github.io/tags/Java集合/"}]},{"title":"Java注解","slug":"JavaAnnotation","date":"2018-12-18T13:34:39.083Z","updated":"2018-12-18T13:34:39.083Z","comments":true,"path":"2018/12/18/JavaAnnotation/","link":"","permalink":"https://batuer.github.io/2018/12/18/JavaAnnotation/","excerpt":"","text":"元数据 https://gitee.com/pianzhi110/Fragmentation/tree/master/app/src/main/java/com/gusi/fragmentation/annotation 要想理解注解（Annotation）的作用，就要先理解Java中元数据的概念。 1.元数据概念元数据是关于数据的数据。在编程语言上下文中，元数据是添加到程序元素如方法、字段、类和包上的额外信息。对数据进行说明描述的数据。 2.元数据的作用一般来说，元数据可以用于创建文档（根据程序元素上的注释创建文档），跟踪代码中的依赖性（可声明方法是重载，依赖父类的方法），执行编译时检查（可声明是否编译期检测），代码分析。如下：1） 编写文档：通过代码里标识的元数据生成文档 2）代码分析：通过代码里标识的元数据对代码进行分析 3）编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查 3.Java平台元数据注解Annotation就是java平台的元数据，是 J2SE5.0新增加的功能，该机制允许在Java 代码中添加自定义注释，并允许通过反射（reflection），以编程方式访问元数据注释。通过提供为程序元素（类、方法等）附加额外数据的标准方法，元数据功能具有简化和改进许多应用程序开发领域的潜在能力，其中包括配置管理、框架实现和代码生成。 注解（Annotation）1.注解（Annotation）的概念注解(Annotation)在JDK1.5之后增加的一个新特性，注解的引入意义很大，有很多非常有名的框架，比如Hibernate、Spring等框架中都大量使用注解。注解作为程序的元数据嵌入到程序。注解可以被解析工具或编译工具解析。 关于注解（Annotation）的作用，其实就是上述元数据的作用。 注意：Annotation能被用来为程序元素（类、方法、成员变量等）设置元素据。Annotaion不影响程序代码的执行，无论增加、删除Annotation，代码都始终如一地执行。如果希望让程序中的Annotation起一定的作用，只有通过解析工具或编译工具对Annotation中的信息进行解析和处理。 2.内建注解Java提供了多种内建的注解，下面接下几个比较常用的注解：@Override、@Deprecated、@SuppressWarnings以及@FunctionalInterface这4个注解。内建注解主要实现了元数据的第二个作用：编译检查。 @Override用途：用于告知编译器，我们需要覆写超类的当前方法。如果某个方法带有该注解但并没有覆写超类相应的方法，则编译器会生成一条错误信息。如果父类没有这个要覆写的方法，则编译器也会生成一条错误信息。 @Override可适用元素为方法，仅仅保留在java源文件中。 @Deprecated用途：使用这个注解，用于告知编译器，某一程序元素(比如方法，成员变量)不建议使用了（即过时了）。 @SuppressWarnings用途：用于告知编译器忽略特定的警告信息，例在泛型中使用原生数据类型，编译器会发出警告，当使用该注解后，则不会发出警告。 注解类型分析： @SuppressWarnings可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。 该注解有方法value(）,可支持多个字符串参数，用户指定忽略哪种警告。 3.元AnnotationJDK除了在java.lang提供了上述内建注解外，还在java.lang。annotation包下提供了6个Meta Annotation(元Annotataion)，其中有5个元Annotation都用于修饰其他的Annotation定义。其中@Repeatable专门用户定义Java 8 新增的可重复注解。 我们先介绍其中4个常用的修饰其他Annotation的元Annotation。在此之前，我们先了解如何自定义Annotation。 当一个接口直接继承java.lang.annotation.Annotation接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过@interface关键字的方式，其实通过该方式会隐含地继承.Annotation接口。 @Documented @Documented用户指定被该元Annotation修饰的Annotation类将会被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。 @Inherited(世袭) 默认情况下,我们自定义的注解用在父类上不会被子类所继承.如果想让子类也继承父类的注解,即注解在子类也生效,需要在自定义注解时设置@Inherited.一般情况下该注解用的比较少. @Retention @Retention：表示该注解类型的注解保留的时长。当注解类型声明中没有@Retention元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留策略，如下表： @Target @Target：表示该注解类型的所适用的程序元素类型。当注解类型声明中没有@Target元注解，则默认为可适用所有的程序元素。如果存在指定的@Target元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素，如下表： 自定义注解（Annotation）创建自定义注解，与创建接口有几分相似，但注解需要以@开头。 其定义是以无形参的方法形式来声明的。 此处只能使用public或者默认的default两个权限修饰符。 配置参数的类型只能使用基本类型(byte,boolean,char,short,int,long,float,double)和String,Enum,Class,annotation。 配置参数一旦设置,其参数值必须有确定的值,要不在使用注解的时候指定,要不在定义注解的时候使用default为其设置默认值,对于非基本类型的参数值来说,其不能为null。 当然注解中也可以不存在成员变量，在使用解析注解进行操作时，仅以是否包含该注解来进行操作。当注解中有成员变量时，若没有默认值，需要在使用注解时，指定成员变量的值。 注解解析接下来，通过反射技术来解析自定义注解。关于反射类位于包java.lang.reflect，其中有一个接口AnnotatedElement，该接口主要有如下几个实现类：Class，Constructor，Field，Method，Package。除此之外，该接口定义了注释相关的几个核心方法，如下：因此，当获取了某个类的Class对象，然后获取其Field,Method等对象，通过上述4个方法提取其中的注解，然后获得注解的详细信息。 注解的应用运行时注解Java反射获取变量或调用方法。 1234567891011121314151617181920212223242526&gt; //view控件&gt; public static void initViews(Object object, View sourceView) &#123;&gt; //获取该类声明的成员变量&gt; Field[] fields = object.getClass().getDeclaredFields();&gt; for (Field field : fields) &#123;&gt; //获取该成员变量上使用的ViewInject注解&gt; ViewInject viewInject = field.getAnnotation(ViewInject.class);&gt; if (viewInject != null) &#123;&gt; int viewId = viewInject.id();//获取id参数值&gt; boolean clickable = viewInject.clickable();//获取clickable参数值&gt; if (viewId != -1) &#123;&gt; try &#123;&gt; field.setAccessible(true);&gt; //赋值&gt; field.set(object, sourceView.findViewById(viewId));&gt; if (clickable == true) &#123;&gt; //click&gt; sourceView.findViewById(viewId).setOnClickListener((View.OnClickListener) (object));&gt; &#125;&gt; &#125; catch (Exception e) &#123;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; 12345678910111213141516&gt; //布局资源&gt; public static void initLayout(Activity activity) &#123;&gt; Class&lt;? extends Activity&gt; activityClass = activity.getClass();&gt; ContentView contentView = activityClass.getAnnotation(ContentView.class);&gt; if (contentView != null) &#123;&gt; int layoutId = contentView.value();&gt; try &#123;&gt; //反射执行setContentView（）方法&gt; Method method = activityClass.getMethod(\"setContentView\", int.class);&gt; method.invoke(activity, layoutId);&gt; &#125; catch (Exception e) &#123;&gt; e.printStackTrace();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 编译时期注解(APT) Annotation Processing Tool 是一种处理在注视的工具，对源代码文件编译时期找出其中的Annotation，进行额外的处理（编译时期生成文件）。 组成要素 注解处理器(AbstractProcess) 12&gt; public class BindViewProcessor extends AbstractProcessor &#123;&#125;&gt; 代码处理(JavaPoet) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&gt; /**&gt; * scan&gt; * process annotation&gt; * mk file&gt; *&gt; * @param set&gt; * @param roundEnvironment&gt; * @return&gt; */&gt; @Override&gt; public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;&gt; mMessager.printMessage(Diagnostic.Kind.NOTE, \"processing..\");&gt; mProxyMap.clear();&gt; //get all BindView annotation&gt; Set&lt;? extends Element&gt; viewElements = roundEnvironment.getElementsAnnotatedWith(BindView.class);&gt; for (Element element : viewElements) &#123;&gt; VariableElement variableElement = (VariableElement) element;&gt; TypeElement classElement = (TypeElement) variableElement.getEnclosingElement();&gt; String fullClassName = classElement.getQualifiedName().toString();&gt; ClassCreatorProxy proxy = mProxyMap.get(fullClassName);&gt; if (proxy == null) &#123;&gt; proxy = new ClassCreatorProxy(mElementUtils, classElement);&gt; mProxyMap.put(fullClassName, proxy);&gt; &#125;&gt; BindView bindAnnotation = variableElement.getAnnotation(BindView.class);&gt; int id = bindAnnotation.value();&gt; proxy.putElement(id, variableElement);&gt; &#125;&gt; &gt; //通过遍历mProxyMap，创建java文件&gt; //通过StringBuilder生成&gt; /*for (String key : mProxyMap.keySet()) &#123;&gt; ClassCreatorProxy proxyInfo = mProxyMap.get(key);&gt; try &#123;&gt; JavaFileObject jfo = processingEnv.getFiler().createSourceFile(proxyInfo.getProxyClassFullName(), proxyInfo.getTypeElement());&gt; Writer writer = jfo.openWriter();&gt; writer.write(proxyInfo.generateJavaCode());&gt; writer.flush();&gt; writer.close();&gt; mMessager.printMessage(Diagnostic.Kind.NOTE, \" --&gt; create \" + proxyInfo.getProxyClassFullName() + \"success\");&gt; &#125; catch (IOException e) &#123;&gt; mMessager.printMessage(Diagnostic.Kind.NOTE, \" --&gt; create \" + proxyInfo.getProxyClassFullName() + \"error\");&gt; &#125;&gt; &#125;*/&gt; //通过javapoet生成&gt; for (String key : mProxyMap.keySet()) &#123;&gt; ClassCreatorProxy proxyInfo = mProxyMap.get(key);&gt; JavaFile javaFile = JavaFile.builder(proxyInfo.getPackageName(), proxyInfo.generateJavaCode2()).build();&gt; try &#123;&gt; //生成文件&gt; javaFile.writeTo(processingEnv.getFiler());&gt; &#125; catch (IOException e) &#123;&gt; e.printStackTrace();&gt; &#125;&gt; &#125;&gt; mMessager.printMessage(Diagnostic.Kind.NOTE, \"process finish ...\");&gt; return false;&gt; &#125;&gt; 处理器注册(AutoService + apt) 1234567&gt; //自动生成&gt; implementation 'com.google.auto.service:auto-service:1.0-rc2'&gt; &gt; @AutoService(Processor.class)&gt; public class BindViewProcessor extends AbstractProcessor &#123;&#125;&gt; &gt; 流程 自定义注解(apt-annotation) 自定义注解处理器(apt-processor) 处理器里面完成处理，生成文件(apt-library) 反射调用 12345678910&gt; public static void bind(Activity activity) &#123;&gt; Class clazz = activity.getClass();&gt; try &#123;&gt; Class bindViewClass = Class.forName(clazz.getName() + \"_ViewBinding\");&gt; Method method = bindViewClass.getMethod(\"bind\", activity.getClass());&gt; method.invoke(bindViewClass.newInstance(), activity);&gt; &#125; catch (Exception e) &#123;&gt; &#125;&gt; &#125;&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://batuer.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://batuer.github.io/tags/Java基础/"},{"name":"Java注解","slug":"Java注解","permalink":"https://batuer.github.io/tags/Java注解/"}]},{"title":"","slug":"GradleCommand","date":"2018-12-18T13:34:39.082Z","updated":"2018-12-18T13:34:39.082Z","comments":true,"path":"2018/12/18/GradleCommand/","link":"","permalink":"https://batuer.github.io/2018/12/18/GradleCommand/","excerpt":"","text":"查看依赖树：gradlew -q app:dependencies 强制清除缓存：gradlew build –refresh-dependencies","categories":[],"tags":[]},{"title":"面试小结","slug":"InterviewSummary","date":"2018-12-18T13:34:39.082Z","updated":"2018-12-18T13:34:39.083Z","comments":true,"path":"2018/12/18/InterviewSummary/","link":"","permalink":"https://batuer.github.io/2018/12/18/InterviewSummary/","excerpt":"","text":"2018-05-07 陕西西建大聚慧 int、short、long字节 | 类型 | 字节 || —— | ——- || int | 4个字节 || char | 2个字节 || byte | 1个字节 || short | 2个字节 || long | 8个字节 || float | 8个字节 || double | 8个字节 | 树、二叉树 Fragment初始化数据 service保活 http://gusi123.cn/2018/06/26/Android%E8%BF%9B%E7%A8%8B%E3%80%81Service%E4%BF%9D%E6%B4%BB/ 锁的使用 线程 MVP、MVC优缺点 MVC(Mode-View-Controller)： 优点： 耦合性不高，View层和Model层分离，减少模块之间的影响。 理解统一，开发维护成本低。 缺点： View层和Model层相互可知(迪米特法则)。 ​ MVP(Model-View-Presenter)： 优点： 降低耦合度，实现Model和View真正的完全分离，可以修改View而不影响Model。 职责明显，层次清晰。 隐藏数据。 Presenter可以复用。 View组件化，提供给上层接口，可以复用View组件。 代码灵活性。 利于测试驱动开发。 缺点 Presenter通信协调View、Model，臃肿。 额外代码。 列表View数据错乱 ItemView缓存复用。 RecyclerView和ListView缓存 http://gusi123.cn/2018/06/27/RecyclerView%E4%B8%8EListView/#ListVIew%E4%B8%8ERecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94 2018-04-27 山东新北洋信息 自定义View http://gusi123.cn/2018/06/08/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/ 事件分发 http://gusi123.cn/2018/06/08/Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/ ListView优化 convertView ViewHolder 分页加载 列表View数据错乱 多层级控件View 2018-09-19 西安纽扣软件 Binder进程通信。 Android事件分发。 Android View绘制流程。 Java封装类 因为泛型类包括预定义的集合，使用的参数都是对象类型，无法直接使用基本类型的数据，所以提供了基本类型的封装类。 Android中为什么主线程不会因为Looper.loop()里的死循环阻塞？ 主线程因为Looper.loop()死循环，每个消息事件时间限制（ANR）。 Android基于事件驱动。","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android面试","slug":"Android面试","permalink":"https://batuer.github.io/tags/Android面试/"}]},{"title":"Git命令","slug":"GitCommand","date":"2018-12-18T13:34:39.081Z","updated":"2018-12-18T13:34:39.081Z","comments":true,"path":"2018/12/18/GitCommand/","link":"","permalink":"https://batuer.github.io/2018/12/18/GitCommand/","excerpt":"","text":"Githug 安装及命令 []: https://github.com/Gazler/githug 安装Ruby 1.8.7 or higher gem install githug 如果遇到权限问题，请加上sudo：sudo gem install githug Commands play hint reset levels 开始游戏 GitLevels 使用githug hint命令根据提示完成，用githug play验证完成结果。 命令 初始化：git init 添加所有：git add . 本地提交信息：git commit -m’*‘ 远程仓库添加：git remote add origin git@gitee.com:** 远程仓库更换：git remote set-url origin git@gitee.com:** 远程提交：git push origin master 查看本地分支：git branch 查看所有分支 ：git branch -a 查看远程分支：git branch -r 删除本地分支：git branch -D xxx 删除远程分支： git push origin delete xxx 拉取远程分支并在本地创建：git checkout -b xxx origin origin/xxx 切换本地分支：git checkout xxx 移除暂存区：git reset HEAD file 丢弃工作区的修改：git checkout – file 查看本地Log：git log 查看远程Log：git log origin/master Log信息一行： git log –pretty=oneline git log –oneline cherry-pick 单个：git cherry-pick commit-id 多个：git cherry-pick commit-id..commit-id 合并 git merge xxx :将xxx分支合并到当前分支: Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。 git rebase xxx :将xxx分支合并到当前分支。 git rebase -i xxx1 xxx2: 合并xxx1到xxx2。 回退： git checkout HEAD^：回退前一个 git checkout HEAD~n：回退n个 提交 撤销 git reset ：本地撤销。 git revert：提交一个新的版本，将需要revert的版本的内容再反向修改回去 git revert 和 git reset的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 Log git log：HEAD及以前 git reflog：所有Log 错误 fatal: refusing to merge unrelated histories git pull origin master –allow-unrelated-histories error:src refspec xxx does not match any git checkout -b xxx","categories":[{"name":"Git","slug":"Git","permalink":"https://batuer.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://batuer.github.io/tags/Git/"}]},{"title":"自定义View","slug":"AndroidView","date":"2018-12-18T13:34:39.080Z","updated":"2018-12-18T13:34:39.080Z","comments":true,"path":"2018/12/18/AndroidView/","link":"","permalink":"https://batuer.github.io/2018/12/18/AndroidView/","excerpt":"","text":"学习链接 View基础View分类 View，不包含子View，所有View的最基类。 ViewGroup，包含子View，也是View的子类。 View构造函数12345678910111213141516171819202122232425262728293031323334353637//代码newpublic MyView(Context context) &#123; super(context);&#125;/** * xml inflate * * @param attrs 属性集，自定义属性也从这里来 */public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs);&#125;/** * 不会主动调用 * * @param defStyleAttr style属性 *//* 1.首先获取给定的AttributeSet中的属性值 2.如果找不到，则去AttributeSet中style（你在写布局文件时定义的style=\"@style/xxxx\"）指定的资源获取 3.如果找不到，则去defStyleAttr以及defStyleRes中的默认style中获取。 4.最后去找的是当前theme下的基础值。 */public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr);&#125;/** * Api &gt;=21 * @param defStyleRes View有style属性时 */@TargetApi(Build.VERSION_CODES.LOLLIPOP)public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes);&#125; View位置(坐标) View Measure作用 某些情况下，需要多次测量才能确定View自身期望和父容器约束条件的综合值。 测量得到的值并不是View最终的值，在layout()后才能得到最终的值。getMeasureWidth()不一定等于getWidth()的原因。 Measure值影响因素ViewGroup.LayoutParams 指定View的宽高值。 1234567891011@ViewDebug.ExportedProperty(category = \"layout\", mapping = &#123; @ViewDebug.IntToString(from = MATCH_PARENT, to = \"MATCH_PARENT\"), @ViewDebug.IntToString(from = WRAP_CONTENT, to = \"WRAP_CONTENT\") &#125;) public int width; @ViewDebug.ExportedProperty(category = \"layout\", mapping = &#123; @ViewDebug.IntToString(from = MATCH_PARENT, to = \"MATCH_PARENT\"), @ViewDebug.IntToString(from = WRAP_CONTENT, to = \"WRAP_CONTENT\") &#125;) public int height; MeasureSpec 简介 定义：测量规格类(测量View大小的指导参数)。 作用：指导作用View的大小。 组成 1int measureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.EXACTLY); 12345678910//Older apps may need this compatibility hack for measurement.//sUseBrokenMakeMeasureSpec = targetSdkVersion &lt;= Build.VERSION_CODES.JELLY_BEAN_MR1;public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; 12345678910//UNSPECIFIED 父容器不约束子View，常用于系统内部 //EXACTLY 父容器指定确切值，子View应该是这个指定值 //AT_MOST 父容器提供一个最大参考值，子View根据自身测量不可超过参考值 @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;) @Retention(RetentionPolicy.SOURCE) public @interface MeasureSpecMode &#123;&#125; 结论：子View的大小由父View的MeasureSpec和自身的LayoutParams属性共同决定子View的大小。 Measure过程 View measure() 1234567891011121314//final 不支持子View重写public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... //测量 int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; //onMeasure 计算大小 onMeasure(widthMeasureSpec, heightMeasureSpec); ... &#125; else &#123; ... &#125; ... &#125; onMeasure() 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 12345678910111213141516171819202122public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; //多为系统调用，getSuggestSize case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; //backGround不为null，固有的尺寸protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; 3. setMeasuredDimension() 1234//赋值 mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight;protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; ... &#125; 4. 完成测量 ViewGroup 原理： 遍历测量所有子View的测量尺寸。 合并所有子View的尺寸得到ViewGroup的测量尺寸。 过程： measure() 1234567891011121314//final 不支持子View重写public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... //测量 int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; //onMeasure 计算大小 onMeasure(widthMeasureSpec, heightMeasureSpec); ... &#125; else &#123; ... &#125; ... &#125; ​ onMeasure() (必须复写,不同ViewGroup有不同的测量布局方式，直接影响ViewGroup的测量尺寸) 1234567891011@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //1.遍历测量子View的尺寸 //2.measureChild //3.getChildMeasureSpec measureChildren(widthMeasureSpec,heightMeasureSpec); //4.合并汇总的到ViewGroup的测量尺寸 int measuredWidth = 0; int measuredHeight = 0; //5.赋值 mMeasuredWidth、mMeasuredHeight setMeasuredDimension(measuredWidth,measuredHeight); &#125; ​ measureChildren() 12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; ​ measureChild() 123456789101112131415161718192021222324 protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125;//自身LayoutParams，可以复写为子View添加自定义属性 @Override protected boolean checkLayoutParams(ViewGroup.LayoutParams p) &#123; return p instanceof LayoutParams; &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new LayoutParams(getContext(), attrs); &#125; @Override protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) &#123; return new LayoutParams(p); &#125; ​ getChildMeasureSpec() 12345678910111213141516final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; ... return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; ​ 遍历子View测量并汇总，ViewGroup根据需求自己实现 setMeasuredDimension()​ View Layout 作用计算确定View的位置，即Left、Top、Right、Bottom的坐标。 Layout过程 View layout() 123456789101112131415161718192021222324//View本身的位置public void layout(int l, int t, int r, int b) &#123; // 当前视图的四个顶点 int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; // 1. 确定View的位置：setFrame（） / setOpticalFrame（） // 即初始化四个顶点的值、判断当前View大小和位置是否发生了变化 &amp; 返回 // -&gt;&gt;分析1、分析2 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); // 2. 若视图的大小 &amp; 位置发生变化 // 会重新确定该View所有的子View在父容器的位置：onLayout（） if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); // 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout（）是一个空实现-&gt;&gt;分析3 // 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout（）在ViewGroup为1个抽象方法，需重写实现（后面会详细说） ...&#125; ViewGroup 原理： 计算自身ViewGroup的位置：layout() 遍历子View并确定子View在ViewGroup的位置(调用子View的layout() )：onLayout() ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 //与单一View的layout（）源码一致 public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; // 1. 确定View的位置： boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); // 2. 若视图的大小 &amp; 位置发生变化 // 会重新确定该View所有的子View在父容器的位置：onLayout（） if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); // 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout（）是一个空实现（上面已分析完毕） // 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout（）在ViewGroup为1个抽象方法，需重写实现 ...&#125; //确定View本身的位置，即设置View本身的四个顶点位置 protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... &#125;//确定View本身的位置(视觉上的)，即设置View本身的四个顶点位置 private boolean setOpticalFrame(int left, int top, int right, int bottom) &#123; ... // 内部实际上是调用setFrame（） return setFrame( left + parentInsets.left - childInsets.left, top + parentInsets.top - childInsets.top, right + parentInsets.left + childInsets.right, bottom + parentInsets.top + childInsets.bottom); &#125; // 回到调用原处/** * 分析3：onLayout（） * 作用：计算该ViewGroup包含所有的子View在父容器的位置（） * 注： * a. 定义为抽象方法，需重写，因：子View的确定位置与具体布局有关，所以onLayout（）在ViewGroup没有实现 * b. 在自定义ViewGroup时必须复写onLayout（）！！！！！ * c. 复写原理：遍历子View 、计算当前子View的四个位置值 &amp; 确定自身子View的位置（调用子View layout（）） */ protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; // 参数说明 // changed 当前View的大小和位置改变了 // left 左部位置 // top 顶部位置 // right 右部位置 // bottom 底部位置 // 1. 遍历子View：循环所有子View for (int i=0; i&lt;getChildCount(); i++) &#123; View child = getChildAt(i); // 2. 计算当前子View的四个位置值 // 2.1 位置的计算逻辑 ...// 需自己实现，也是自定义View的关键 // 2.2 对计算后的位置值进行赋值 int mLeft = Left int mTop = Top int mRight = Right int mBottom = Bottom // 3. 根据上述4个位置的计算值，设置子View的4个顶点：调用子view的layout() &amp; 传递计算过的参数 // 即确定了子View在父容器的位置 child.layout(mLeft, mTop, mRight, mBottom); // 该过程类似于单一View的layout过程中的layout（）和onLayout（），此处不作过多描述 &#125; &#125; &#125; View Draw作用绘制View视图 过程 原理 View绘制自身(背景、内容)。 绘制装饰(滚动条、滚动指示器、前景等)。 流程 draw() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 源码分析：draw（） * 作用：根据给定的 Canvas 自动渲染 View（包括其所有子 View）。 * 绘制过程： * 1. 绘制view背景 * 2. 绘制view内容 * 3. 绘制子View * 4. 绘制装饰（渐变框，滑动条等等） * 注： * a. 在调用该方法之前必须要完成 layout 过程 * b. 所有的视图最终都是调用 View 的 draw （）绘制视图（ ViewGroup 没有复写此方法） * c. 在自定义View时，不应该复写该方法，而是复写 onDraw(Canvas) 方法进行绘制 * d. 若自定义的视图确实要复写该方法，那么需先调用 super.draw(canvas)完成系统的绘制，然后再进行自定义的绘制 */ public void draw(Canvas canvas) &#123; ...// 仅贴出关键代码 int saveCount; // 步骤1： 绘制本身View背景 if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // 若有必要，则保存图层（还有一个复原图层） // 优化技巧：当不需绘制 Layer 时，“保存图层“和“复原图层“这两步会跳过 // 因此在绘制时，节省 layer 可以提高绘制效率 final int viewFlags = mViewFlags; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // 步骤2：绘制本身View内容 if (!dirtyOpaque) onDraw(canvas); // View 中：默认为空实现，需复写 // ViewGroup中：需复写 // 步骤3：绘制子View // 由于单一View无子View，故View 中：默认为空实现 // ViewGroup中：系统已经复写好对其子视图进行绘制我们不需要复写 dispatchDraw(canvas); // 步骤4：绘制装饰，如滑动条、前景色等等 onDrawScrollBars(canvas); return; &#125; ... &#125; ​ drawBackground() 1234567891011121314151617181920212223/** * 步骤1：drawBackground(canvas) * 作用：绘制View本身的背景 */ private void drawBackground(Canvas canvas) &#123; // 获取背景 drawable final Drawable background = mBackground; if (background == null) &#123; return; &#125; // 根据在 layout 过程中获取的 View 的位置参数，来设置背景的边界 setBackgroundBounds(); ..... // 获取 mScrollX 和 mScrollY值 final int scrollX = mScrollX; final int scrollY = mScrollY; if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; // 若 mScrollX 和 mScrollY 有值，则对 canvas 的坐标进行偏移 canvas.translate(scrollX, scrollY); // 调用 Drawable 的 draw 方法绘制背景 background.draw(canvas); canvas.translate(-scrollX, -scrollY); } } 1234 ​3. onDraw() /** 作用：绘制View本身的内容 注： a. 由于 View 的内容各不相同，所以该方法是一个空实现 b. 在自定义绘制过程中，需由子类去实现复写该方法，从而绘制自身的内容 c. 谨记：自定义View中 必须 且 只需复写onDraw（）*/protected void onDraw(Canvas canvas) { … // 复写从而实现绘制逻辑 } 123456789101112131415161718192021222324252627282930 ​4. dispatchDraw() ```java //View 没有子View空实现 //ViewGroup protected void dispatchDraw(Canvas canvas) &#123; ...... // 1. 遍历子View final int childrenCount = mChildrenCount; ...... for (int i = 0; i &lt; childrenCount; i++) &#123; ...... if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; // 2. 绘制子View more |= drawChild(canvas, transientChild, drawingTime); &#125; .... &#125; &#125; //绘制子View protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime); &#125; ​ onDrawForeground() 1234567891011121314151617181920212223242526272829public void onDrawForeground(Canvas canvas) &#123; //滚动条指示器 onDrawScrollIndicators(canvas); //滚动条 onDrawScrollBars(canvas); //前景 final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null; if (foreground != null) &#123; if (mForegroundInfo.mBoundsChanged) &#123; mForegroundInfo.mBoundsChanged = false; final Rect selfBounds = mForegroundInfo.mSelfBounds; final Rect overlayBounds = mForegroundInfo.mOverlayBounds; if (mForegroundInfo.mInsidePadding) &#123; selfBounds.set(0, 0, getWidth(), getHeight()); &#125; else &#123; selfBounds.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom()); &#125; final int ld = getLayoutDirection(); Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(), foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld); foreground.setBounds(overlayBounds); &#125; foreground.draw(canvas); &#125; &#125; 加入自己想要绘制的内容。 View.setWillNotDraw()，标记View是否需要绘制，系统优化ViewGroup默认为true。","categories":[{"name":"Activity","slug":"Activity","permalink":"https://batuer.github.io/categories/Activity/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"View基础","slug":"View基础","permalink":"https://batuer.github.io/tags/View基础/"},{"name":"View Measure","slug":"View-Measure","permalink":"https://batuer.github.io/tags/View-Measure/"},{"name":"View Layout","slug":"View-Layout","permalink":"https://batuer.github.io/tags/View-Layout/"},{"name":"View Draw","slug":"View-Draw","permalink":"https://batuer.github.io/tags/View-Draw/"}]},{"title":"Android进程保活Service常驻","slug":"AndroidProcess&ServiceKeep-alive","date":"2018-12-18T13:34:39.079Z","updated":"2018-12-18T13:34:39.079Z","comments":true,"path":"2018/12/18/AndroidProcess&ServiceKeep-alive/","link":"","permalink":"https://batuer.github.io/2018/12/18/AndroidProcess&ServiceKeep-alive/","excerpt":"","text":"https://mp.weixin.qq.com/s/OXiFQNTyCHpqSP6B9HOiHw 进程保活进程保活两个层面： 提高进程优先级，降低被系统杀死概率。 进程被杀死后，进行拉活。 进程的优先级 前台进程：前台进程不多，内存不足时系统才会清理。 正在可交互的Activity(onResume()和onStart()区别)。 Service绑定到正在可交互的Activity。 前台Service 123public final void startForeground(int id, Notification notification) &#123;&#125;public ComponentName startForegroundService(Intent service) &#123;&#125; 正执行生命周期的Service。 正执行生命周期的BroadcastReceiver。 可见进程：可见不可交互的进程。 Activity执行onStart()未执行onStop()。 Service绑定到可见的Activity。 服务进程：进程中有Service正在运行。 后台进程：进程最后一个Activity执行onStop()。 空进程：这种进程唯一目的用作缓存，缩短下次启动时间。 提升进程优先级利用Activity提升权限 监控解锁屏事件，锁屏时启动1个像素的透明Activity，解锁时销毁。 可以使进程变为可见进程。 利用Notification提升权限 普通服务进程升级为前台进程，会在通知栏有通知，用户可感知。 通过实现一个内部 Service，在 LiveService 和其内部 Service 中同时发送具有相同 ID 的 Notification，然后将内部 Service 结束掉。随着内部 Service 的结束，Notification 将会消失，但系统优先级依然保持为2。 进程杀死后拉活利用系统广播 注册静态广播监听系统广播事件。 广播管理器会被系统软件或管理软件禁用进而无法接收到广播。 系统广播事件不可控。 利用第三方应用广播 反编译监听第三方应用会发送的广播。 存在第三方广播会升级修改，不能及时通知。 利用系统Service机制拉活 1234@Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return Service.START_STICKY; &#125; Service 第一次被异常杀死后会在5秒内重启，第二次被杀死会在10秒内重启，第三次会在20秒内重启，一旦在短时间内 Service 被杀死达到5次，则系统不再拉起。 进程被取得 Root 权限的管理工具或系统工具通过 forestop 停止掉，无法重启。 利用Native进程拉活 利用 Linux 中的 fork 机制创建 Native 进程，在 Native 进程中监控主进程的存活，当主进程挂掉后，在 Native 进程中立即对主进程进行拉活。 …… 利用JobScheduler机制拉活 Android5.0 以后系统对 Native 进程等加强了管理，Native 拉活方式失效。系统在 Android5.0 以上版本提供了 JobScheduler 接口，系统会定时调用该进程以使应用进行一些逻辑操作。 利用账号同步机制 Android 系统的账号同步机制会定期同步账号进行，该方案目的在于利用同步机制进行进程的拉活。 该方案适用于所有的 Android 版本，包括被 forestop 掉的进程也可以进行拉活。 最新 Android 版本（Android N）中系统好像对账户同步这里做了变动，该方法不再有效。 其它方案 利用系统通知管理权限进行拉活 。 利用辅助功能拉活，将应用加入厂商或管理软件白名单。 根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。 Service常驻 JNI：5.0以前，Android系统本身不管理JNI层的，用Linux的Fork机制将App和进程分开。 JobService：可以在自动创建进程后台干任何事情，包括拉活activity、service或者执行任何的代码。但JobService并不意味着你不受任何限制，比如受到doze、monitor之类的管理。 前台服务。 Service 的 onstartCommand()。","categories":[{"name":"进程、Service保活","slug":"进程、Service保活","permalink":"https://batuer.github.io/categories/进程、Service保活/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"进程保活","slug":"进程保活","permalink":"https://batuer.github.io/tags/进程保活/"},{"name":"Service保活","slug":"Service保活","permalink":"https://batuer.github.io/tags/Service保活/"}]},{"title":"Android多进程","slug":"AndroidMultiProcess","date":"2018-12-18T13:34:39.078Z","updated":"2018-12-18T13:34:39.078Z","comments":true,"path":"2018/12/18/AndroidMultiProcess/","link":"","permalink":"https://batuer.github.io/2018/12/18/AndroidMultiProcess/","excerpt":"","text":"多进程概念多进程就是多个进程。一个应用程序默认只有一个进程，这个进程的名称就是报名。 进程是系统资源个分配的基本单位，线程死调度的基本单位。 每个进程都有自己独立的资源和内存空间。 其它进程不可随意访问其它进程的内存和资源。 系统给每个进程分配的内存有限制。 多进程的创建四大组件在AndroidManifset文件中注册的时候，有个属性android:process这里可以指定组件多出的进程。默认主进程。android:process=”:deamon”以:开头的名字位私有进程，否则全局进程。 多进程的优缺点 好处 分担主进程内存压力，将一些独立的组件放到不同的进程中，它就不占用主进程的内存空间，如大图片或多图片的组件或WebView。 帮助应用常驻后台，防止主进程被杀守护进程，主进程与守护进程相互监视唤醒。 坏处 消耗用电 多占用系统空间 必要时需要处理多进程间通信。 多进程的缺陷 Application多次重建 获取进程id获取进程名称，处理相应进程的业务 静态成员失效 使用Intent或aidl等进程通信方式传递内容，不能使用静态或单例模式。 文件共享问题 多进程并发操作数据库，难以通过锁机制控制，考虑都使用主进程进行数据库操作(ContentProvider)。 断点调试问题 调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试。因此要改为同一进程：调试时去掉AndroidManifest.xml中android:process标签，这样保证调试状态下是在同一进程中，堆栈信息是连贯的。待调试完成后，再将标签复原。 多进程间通信IPC 通过Intent/Bundle传递数据 通过文件缓存，一个进程写另一个进程读取 通过ContentProvider提供入口，共享数据 通过Socket方式，系统中的进程服务也有如此方式 通过AIDL实现进程通信，可以做到多端连接，异步通信，避免阻塞 Messenger 利用Handler实现，适用于多进程、单线程、不需要考虑线程安全。底层基于AIDL实现。 通过广播","categories":[{"name":"多进程","slug":"多进程","permalink":"https://batuer.github.io/categories/多进程/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"多进程","slug":"多进程","permalink":"https://batuer.github.io/tags/多进程/"}]},{"title":"Android性能优化","slug":"AndroidPerformanceOptimization","date":"2018-12-18T13:34:39.078Z","updated":"2018-12-18T13:34:39.078Z","comments":true,"path":"2018/12/18/AndroidPerformanceOptimization/","link":"","permalink":"https://batuer.github.io/2018/12/18/AndroidPerformanceOptimization/","excerpt":"","text":"性能优化 流畅(卡顿优化) 内存优化 耗电优化 安装包大小优化 卡顿优化 原因 绘制任务太重，绘制一帧内容耗时太长。 主线程太忙，根据系统传递过来的 VSYNC 信号来时还没准备好数据导致丢帧。 优化 界面绘制卡顿 布局优化：布局嵌套过深、使用合适布局。列表控件缓存复用、include、merge、ViewStub、移除Activity默认背景。 数据处理阻塞UI线程。 获取数去耗时，占用UI线程。 处理数据占用CPU高，UI线程拿不到时间片。 内存占用过大 具体见内存优化。 启动优化 绘制优化。 启动加载逻辑优化。 可延迟初始化项，延迟初始化。 动画优化 可以使用硬件加速，提高流畅度。 工具 System Trace（收集和检测时间信息，CPU的消耗） Hierarchy Viewer（布局层级、绘制） TraceView（定位代码的执行时间） AndroidStudio3.0 自带的 Profiler 内存优化内存优化主要就是消除应用中的内存泄漏、避免内存抖动。 Android应用的沙箱机制，每个应用所分配的大小是有限度的，内存太低会被系统清除，即会出现闪退现象。搞懂Android内存管理机制，如何分配和回收的。 Android应用都是在Android虚拟机上运行，应用后才能徐的内存分配与垃圾回收都是由虚拟机完成的，因此不需要在代码中分配和释放内存。 Android内存分配回收机制 Anroid基于进程中运行的组件及其状态规定了默认的五个回收优先级：Empty process(空进程) &gt; Background process(后台进程) &gt; Service process(服务进程) &gt; Visible process(可见进程) &gt; Foreground process(前台进程)。 Android中由ActivityManagerService 集中管理所有进程的内存资源分配。 Android Dalvik Heap与原生Java一样，将堆的内存空间分为三个区域，Young Generation，Old Generation， Permanent Generation。最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。系统会根据内存中不同的内存数据类型分别执行不同的gc操作。GC发生的时候，所有的线程都是会被暂停的。执行GC所占用的时间和它发生在哪一个Generation也有关系，Young Generation中的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。 内存常见问题及解决 内存泄漏 单例（主要原因还是因为一般情况下单例都是全局的，有时候会引用一些实际生命周期比较短的变量，导致其无法释放） 静态变量（同样也是因为生命周期比较长） Handler内存泄露[ 匿名内部类（匿名内部类会引用外部类，导致无法释放，比如各种回调） 资源使用完未关闭（BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap） 内存泄漏检测LeakCanary，监控每个Activity，在activity ondestory后，在后台线程检测引用，然后过一段时间进行gc，gc后如果引用还在，那么dump出内存堆栈，并解析进行可视化显示。 资源性对象未关闭。比如Cursor、File文件等，往往都用了一些缓冲，在不使用时，应该及时关闭它们。 注册对象未注销。比如事件注册后未注销，会导致观察者列表中维持着对象的引用。 WebView。WebView 存在着内存泄漏的问题，在应用中只要使用一次 WebView，内存就不会被释放掉。 图片分辨率相关 很多情况下图片所占的内存在整个App内存占用中会占大部分。适配不同屏幕的图片资源。 优先考虑率使用webp格式图片代替传统格式图片。 图片压缩 BitmapFactory 在解码图片时，可以带一个Options参数，适当配置该参数。 缓存池大小 图片加载组件都不仅仅是使用软引用或者弱引用了，实际上类似Glide 默认使用的事LruCache，因为软引用 弱引用都比较难以控制，使用LruCache可以实现比较精细的控制，而默认缓存池设置太大了会导致浪费内存，设置小了又会导致图片经常被回收，所以需要根据每个App的情况，以及设备的分辨率，内存计算出一个比较合理的初始值，可以参考Glide的做法。 内存抖动 内存抖动引起OOM。大量小的对象频繁创建，导致内存碎片，从而当需要分配内存时，虽然总体上还是有剩余内存可分配，而由于这些内存不连续，导致无法分配，系统直接就返回OOM了。 常用数据结构优化 ArrayMap及SparseArray是android的系统API，是专门为移动设备而定制的。用于在一定情况下取代HashMap而达到节省内存的目的,具体性能见HashMap，ArrayMap，SparseArray源码分析及性能对比，对于key为int的HashMap尽量使用SparceArray替代，大概可以省30%的内存，而对于其他类型，ArrayMap对内存的节省实际并不明显，10%左右，但是数据量在1000以上时，查找速度可能会变慢。 枚举 Android平台上枚举是比较争议的，在较早的Android版本，使用枚举会导致包过大，在个例子里面，使用枚举甚至比直接使用int包的size大了10多倍 ，使用枚举需要谨慎，因为枚举变量可能比直接用int多使用2倍的内存。 尽量使用系统资源。 减少view的层级。 数据相关 使用protobuf。 dex优化，代码优化，谨慎使用外部库。 常用工具 Memory Analyzer(MAT)工具。MAT使用教程)，MAT - Memory Analyzer Tool 使用进阶)。 内存泄漏检测 Leakcanary。 AndroidStudio3.0 自带的 Profiler。 Android Lint 工具。 耗电优化Android5.0 以前，在应用中测试电量消耗比较麻烦，也不准确，5.0 之后专门引入了一个获取设备上电量消耗信息的 API:Battery Historian。Battery Historian 是一款由 Google 提供的 Android 系统电量分析工具，和Systrace 一样，是一款图形化数据分析工具，直观地展示出手机的电量消耗过程，通过输入电量分析文件，显示消耗情况，最后提供一些可供参考电量优化的方法。 常用方案： 计算优化，避开浮点运算等。 避免 WaleLock 使用不当。 使用 Job Scheduler。 安装包大小优化应用安装包大小对应用使用没有影响，但应用的安装包越大，用户下载的门槛越高，特别是在移动网络情况下，用户在下载应用时，对安装包大小的要求更高，因此，减小安装包大小可以让更多用户愿意下载和体验产品。常用方案： 代码混淆。使用proGuard 代码混淆器工具，它包括压缩、优化、混淆等功能。 资源优化。比如使用 Android Lint 删除冗余资源，资源文件最少化等。 图片优化。比如利用 AAPT 工具对 PNG 格式的图片做压缩处理，降低图片色彩位数等。 避免重复功能的库，使用 WebP图片格式等。 插件化。比如功能模块放在服务器上，按需下载，可以减少安装包大小。","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"性能优化","slug":"性能优化","permalink":"https://batuer.github.io/tags/性能优化/"}]},{"title":"Android面试","slug":"AndroidInterview","date":"2018-12-18T13:34:39.077Z","updated":"2018-12-18T13:34:39.077Z","comments":true,"path":"2018/12/18/AndroidInterview/","link":"","permalink":"https://batuer.github.io/2018/12/18/AndroidInterview/","excerpt":"","text":"一、JavaJava基础 对封装、抽象、继承、多态的理解 封装：面向对象重要原则，把过程和数据包围起来，数据的访问通过自定义接口，隐藏内部实现细节。增加安全性。 抽象：同一事物共有属性和方法的集合，多态的基础。 继承：代码复用的重要手段。单继承特点，只有一个父类，继承父类非私有属性和方法。根据自身需求扩展。 多态：同一种行为具有不同的表现形态或形式的能力。程序中定义的引用变量在编译时期不能确定具体类型，在运行中才能知道具体类型。 泛型的作用及使用场景 作用：编译阶段完成类型转换，避免运行时期转换异常。类型安全。 场景： 泛型类和接口 泛型方法 泛型构造器 类型通配符，上限和下限通配符。 枚举的特点及使用场景 特点： 枚举的直接父类是java.lang.Enum，但是不能显示的继承Enum。 枚举就相当于一个类，可以定义构造方法、成员变量、普通方法和抽象方法。 每个实例分别用于一个全局常量表示，枚举类型的对象是固定的，实例个数有限，不能使用new关键字。 枚举实例后有花括号时，该实例是枚举的匿名内部类对象。 场景： 普通常量。 枚举中添加变量、构造函数，灵活获取指定值。 添加自己特定的方法，实现自己的需求。根据code获取相应的对应值。（常见于原因Code获取具体原因描述） 线程sleep和wait的区别 sleep（）属于Thread，wait（）属于Object.。 sleep（）仅仅是睡眠，不涉及到锁的释放问题，让出CPU，睡眠时间结束自动竞争CPU执行。 wait（）绑定了某个对象的锁，等待该对象的notify（），notifyAll（）来唤醒自己，等待的时间是未知的，甚至出现死锁。 无论怎用sleep都会释放cpu，但是在线程池中会占用位置。（CPU和线程区别）。 JAVA反射机制 Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 生成动态代理。 weak/soft/strong引用的区别 JAVA虚拟机通过可达性（Reachability)来判断对象是否存活，基本思想：以”GC Roots”的对象作为起始点向下搜索，搜索形成的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（即不可达的），则该对象被判定为可以被回收的对象，反之不能被回收。 Strong：普通的java引用，我们通常new的对象就是： StringBuffer buffer = new StringBuffer(); 如果一个对象通过一串强引用链可达，那么它就不会被垃圾回收。 Soft：当内存不足的时候才回收它。 Weak：一旦gc发现对象是weakReference可达，就会把它放到ReferenceQueue中，下次gc时回收它。 Phantom：和soft，weak Reference区别较大，它的get()方法总是返回null。 Object的hashCode()与equals()的区别和作用 equals() 的作用是 用来判断两个对象是否相等。 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode是为了提高在散列结构存储中查找的效率，在线性表中没有作用。 interface和abstract class区别 Java抽象类定义的两种机制，这两张机制赋予了Java强大的面向对象能力。两者有很大相似性，也可以相互替换，但两者之间也有很大区别。 抽象类：在代码中使用abstract修饰的class即为抽象类，类对象的抽象集合。具体的使用中主要用来进行类型隐藏，我们可以构造出一组固定的行为，这组行为却能够有任意个可能的具体实现，这个抽象描述就是抽象类，这一组任意个可能的具体实现则表现为泽类。这样模块可以操作一个抽象提，由于模块依赖于一个固定的抽象提，一次它可以使不允许修改的，但是允许扩展，这就是面向对象设计的一个核心原则OCP，抽象是关键所在。 接口：比abstract class更加抽象，是一种特殊的abstract class。用Interface关键字修饰，类方法的抽象集合。为了把程序模块进行固话契约，降低耦合。 集合类 JAVA常用集合类功能、区别和性能 Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。 ​ 图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。 Collection: 最基本的集合类型，实现Iterable接口。 List: 有序，可重复。 LinkedList: 双向链表实现，可被用作堆栈、队列、双向队列，set和get函数以O(n/2)的性能获取一个节点。 ArrayList: 数组实现，自动扩容。 Vector: 数组实现，自动扩容，同步存取。 Stack: 继承Vector,实现后进先出堆栈，提供5个额外方法使得Vector当堆栈使用。 Set: 不可重复。 HashSet: 代用对象hashCode，计算存放位置,通过hashCode 和equals判断重复。(HashMap的Key的判断,无序) TreeSet: 排序。(TreeMap存取) Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。 图中，HashMap和TreeMap经常用到。 Map: Key和Value 的映射，不包含相同的Key。 HashTable: 同步，存取非空对象。(Entrty对象) HashMap: 不同步，允许空对象，不保证有序，存储Entrty。 Treemap: 类似HashMap，实现排序。 LinkedHashMap: Hash表和链表的实现，类似HashMap，保证双向链表节点的顺序。 WeakHashMap: key弱应用。 ArrayMap: 没用Entrty，由两数组维护。速度慢于HashMap，有排序，二分法查找，数组收缩功能，时间换空间。 并发相关的集合类 Vector Synchronize实现 数组保证顺序 自动扩容，System.arraycopy()效率低 适合一次赋值多次读取，数据量小的多线程环境 Stack Vector子类,扩展5个关于栈的操作方法 栈先进后出 HashTable Synchronize实现 Entrty对象 Concurrent包提供的线程安全集合 ConcurrentHashMap 不允许空键值对 使用ReentranLock保证线程安全 ConcurrentLinkedDeque 双端队列 Linked大小不受限 ConcurrentLinkedQueue ConcurrentSkipListMap ConcurrentSkipSet 基于ConcurrentSkipListMap实现 CopyOnWriteArrayList 写入时赋值数组 ReentrantLock实现线程安全 保证数据多线程最终一致性 Copy两份数组，内存浪费。 部分常用集合类的内部实现方式 多线程相关 Thread、Runnable、Callable、Futrue类关系与区别 Thread 实现Runnable接口 提供线程等待、睡眠、礼让等操作 Runnable 接口 无返回值 Callable 接口 有返回值he Future 对Runnable和Callable任务的执行结果进行取消、查询是否完成、获取结构。设置结果等操作 FutureTask Runnable和Future结合 JDK中默认提供了哪些线程池，有何区别 https://batuer.github.io/2018/03/15/Executor/ 线程同步有几种方式，分别阐述在项目中的用法 临界区 通过对多线程串行化来访问公共资源或一段代码，速度快，是个控制数据访问。任何时刻只允许一个线程对共享资源访问。多线程访问时，刚起其它等待线程，一直等到临界区的线程离开。 Step 定义临界区对象Lock 访问共享资源之前，获得临街对象Lock.lock() 访问资源后，放弃临界对象Lock.unlock() 互斥量 (互斥锁) 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，互斥对象只有一个。 信号量 允许多线程访问公共资源，但是限制同一时刻访问该资源的最大线程数 事件 通过通知方式保持线程同步，并可实现优先级操作。 具体实现 同步方法：synchronized修饰方法。 同步代码块：synchronized修饰语句块 同步是一种高开销操作，减少同步内容。没有必要同步整个方法时，同步关键语句块。 特殊域变量(volatile)实现线程同步（可见性） volatile关键字为域变量的访问提供了一种免锁机制 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新 因此每次使用该域就要重新计算，而不是使用寄存器中的值 volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 使用重入锁 在JavaSE5.0中新增了一个java.util.concurrent包来支持同步 ReentrantLock类是可重入、互斥、实现了Lock接口的锁 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力 注：关于Lock对象和synchronized关键字的选择 最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码 如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 使用局部变量实现线程同步 如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响 Volatile与Synchronized 对于volatile修饰的变量，当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的，volatile变量对所有线程是立即可见的，对volatile变量的所有写操作都能立刻反应到其他线程之中。 VM规范规定了任何一个线程修改了volatile变量的值都需要立即将新值更新到主内存中, 任何线程任何时候使用到volatile变量时都需要重新获取主内存的变量值 两者区别 volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化（禁止指令重排序优化，即执行顺序与程序顺序一致）；synchronized标记的变量可以被编译器优化 在理解默认线程池的前提下，自己实现线程池 字符 String的不可变性 不可变对象：基础类型对象之不能改变，引用类型对象的引用不能改变。 节省内存空间 多线程同步 hashcode唯一，效率高 StringBuilder和StringBuffer的区别 StringBuilder线程不安全 StringBuffer线程安全 字符集的理解：Unicode、UTF-8、GB2312等 正则表达式相关问题 注解 http://gusi123.cn/2018/02/24/JavaAnnotaion/ 注解的使用 编写文档 代码分析 编译检查 注解的级别及意义 ​ 如何自定义注解 反射技术解析自定义注解 二、Android技术Android基础 四大组件的意义及使用，生命周期回调及意义 AsyncTask、Handler的使用 https://batuer.github.io/2018/03/23/AsyncTask/ Android系统层次框架结构 https://batuer.github.io/2018/03/21/AnrdroidFrameWork/ AsyncTask的实现方式 https://batuer.github.io/2018/03/23/AsyncTask/ 封装ThreadPoolExecutor和Handler执行线程任务并且完成结果回调。 AsyncTask使用的时候应该注意什么 https://batuer.github.io/2018/03/23/AsyncTask/ 版本不同任务执行方式不同，3.0以上默认串行。 容易造成内存泄漏。 只能执行一次任务。 Android常见的存储方式 内存 外部SD卡 SharedPreferences Sqlite Looper、Handler和MessageQueue的关系 Handler封装消息的发送、接收，内部和Looper关联。 Looper循环从MessageQueue取出消息交给Handler处理。 MessageQueue消息队列，供Looper取。 Activity的启动流程（考察对Framwork的熟悉程度） http://gusi123.cn/2018/03/27/Activity启动流程/ 多进程开发的注意事项(Application类区分进程，进程间内存不可见、进程间通讯方式) http://gusi123.cn/2018/03/26/MultiProcess/ Resource相关 .9图片的意义 style和theme的作用及用法 dpi、sp、px的区别以及转换关系 px是像素，屏幕上实际的像素点单位。 dip/dp设备独立像素，布局常使用，与屏幕有关，在不同像素密度的设备上会自动适配。 sp放大像素，处理字体大小。 dpi 像素密度，每平方英寸中的像素数。 px和dp转换：px=1dp 像素密度(dpi) / 160 =dp density raw和assets文件夹的作用，二者有何区别 两者目录下的文件在打包后会原封不动的保存在apk包中,不会被编译成二进制。 res/raw中的文件会被映射到R.java文件中,访问的时候直接使用资源ID即R.id.filename; 而assets文件夹下的文件不会被映射到R.java中,访问的时候需要AssetManager类。 res/raw不可以有目录结构,而assets则可以有目录结构,也就是assets目录下可以再建立文件夹。 读取res/raw下的文件资源,通过以下方式获取输入流来进行写操作InputStreamis=getResources().openRawResource(R.id.filename);//通过 资源 id 直接打开 raw 下的 流文件 读取assets下的文件资源,通过以下方式获取输入流来进行写操作，InputStream is = getAssets().open(“filename”); Android系统如何在多个资源文件夹下查找匹配最合适的资源 https://www.jianshu.com/p/fd07300b031a 对于资源文件夹的命名必须按照上表中的顺序依次配置，切不可倒置。 虚拟机 Java内存模型 Android虚拟机的特点 Dalvik和Art的区别 熟悉垃圾回收的实现机制，辣椒虚拟机的GC类型 View相关 常用组件的使用：ListView、RecyclerView及Adapter的使用 View之间的继承关系 invalidate和postInvalidate的区别 自定义View onMeasure、onLayout、onDraw的作用 Paint、Matrix、Shader等回执相关类的方法作用 事件分发机制 动画 Android有哪些动画实现方式 Interpolator类的意义和常用的Interpolator ViewAnimation与属性动画有什么区别 如何自定义ViewAnimation 属性动画的实现原理 图片处理 一般项目中如何加载大图 图片压缩方式 如何不压缩图片加载高清图 图片加载过程中，一般会使用缓存，这个缓存的主要作用是什么 图片加载框架对比","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android面试","slug":"Android面试","permalink":"https://batuer.github.io/tags/Android面试/"}]},{"title":"Android事件","slug":"AndroidEvent","date":"2018-12-18T13:34:39.075Z","updated":"2018-12-18T13:34:39.075Z","comments":true,"path":"2018/12/18/AndroidEvent/","link":"","permalink":"https://batuer.github.io/2018/12/18/AndroidEvent/","excerpt":"","text":"事件一般有 MotionEvent.ACTION_DOWN MotionEvent.ACTION_UP MotionEvent.ACTION_MOVE MotionEvent.ACTION_CANCEL(触摸移出第一消费事件View外) 事件顺序Activity → ViewGroup → … →View 相应决定事件分发、拦截、消费的具体 Activity dispatchTouchEvent 1234567891011public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; //空方法，实现屏保功能，当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 onUserInteraction(); &#125; //重要！！！ 找到PhoneWindow及DecoreView，往下传递事件 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; onTouchEvent(消费事件，true消费) ViewGroup dispatchTouchEvent onInterceptTouchEvent onTouchEvent View dispatchTouchEvent onTouchEvent super很重要决定事件的下一步走向，不执行super时谨慎使用(如Activity的super.dispatchTouchEvent(ev))。","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"事件","slug":"事件","permalink":"https://batuer.github.io/tags/事件/"}]},{"title":"Android广播","slug":"AndroidBroadcast","date":"2018-12-18T13:34:39.074Z","updated":"2018-12-18T13:34:39.074Z","comments":true,"path":"2018/12/18/AndroidBroadcast/","link":"","permalink":"https://batuer.github.io/2018/12/18/AndroidBroadcast/","excerpt":"","text":"概述 四大组件之一。 基于消息的发布/订阅模式（高内聚低耦合）。 订阅者在AMS中注册感兴趣的广播。 发布者发送广播到AMS中查找注册者。 异步处理。 注册过程 分为动态注册和静态注册（常驻型）。 ContextImpl通过Binder机制向AMS完成广播注册。 注册过程的核心就是将广播接收者和IntentFilter保存在AMS中。 发送过程 发送者调用sendBroadcast()发送广播，通过Binder机制向AMS发送广播，在AMS中查找注册关系表里查找感兴趣的接收者。 发送过程是异步的。 使用场景 同一App内部不同组件之间的消息通信（多线程）。 同一App内部不同组件之间的消息通信（单进程）。 同一App内不同进程间的组件消息通信（多进程）。 不同App之间组件消息通信。 Android系统在特定情况下与App间的消息通信（系统广播）。 广播接收器回调在UI线程，不执行耗时操作。 注册方式 动态注册 Context调用registerReceiver()注册，退出时及时反注册。 静态注册 android:exported ：BroadcastReceiver能否接收其他App的发出的广播，这个属性默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）。 android:name ：BroadcastReceiver类名 。 android:permission ：具有相应权限的广播发送方发送的广播才能被此BroadcastReceiver所接收。 android:process ：broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程）。 广播类型Normal Broadcast 开发者自己定义的Intent。 无序。 权限对应。 System Broadcast 系统发送的广播（开机启动、网络状态、蓝牙等等）。 Ordered Broadcast 针对接收者的顺序。 动态广播优于静态广播。 优先接收者可对广播拦截或修改。 Sticky Broadcast API 21以后不再推荐使用。 @Deprecated。 Sticky Order Broadcast 也同样@Deprecated。 Local Broadcast App应用内广播（Application或Application User id为界）。 不接收其它应用相同IntentFilter的广播。 不让其它应用接收相同IntentFilter的广播。 安全方案 android:exported为false时，不接收其它应用的广播干扰。 android:permission：发送和接收都添加权限验证。 发送广播时指定接收者的包名。 应用内广播（LocalBroadcastManager）。 安全性高、更高效。 LocalBroadcastManager发送的应用内广播，只能是LocalBroadcastManager动态注册的广播才能接收到。 广播接收器回调onReceiver(context,intent)中context的具体类型 对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext。 对于全局广播的动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context。 对于通过LocalBroadcastManager动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Application Context。 不同API版本的广播机制重要变迁 API level 21开始粘滞广播和有序粘滞广播过期，以后不再建议使用。 静态注册的广播接收器即使app已经退出，只要有相应的广播发出，依然可以接收到，但此种描述自Android 3.1开始有可能不再成立。 Android 3.1开始系统在Intent与广播相关的flag增加了参数，分别是FLAG_INCLUDE_STOPPED_PACKAGES（即包所在的进程已经退出）和FLAG_EXCLUDE_STOPPED_PACKAGES（不包含已经停止的包）。 Android3.1开始，系统本身则增加了对所有app当前是否处于运行状态的跟踪。在发送广播时，不管是什么广播类型，系统默认直接增加了值为FLAG_EXCLUDE_STOPPED_PACKAGES的flag，导致即使是静态注册的广播接收器，对于其所在进程已经退出的app，同样无法接收到广播。由此，对于系统广播，由于是系统内部直接发出，无法更改此intent flag值，因此，3.1开始对于静态注册的接收系统广播的BroadcastReceiver，如果App进程已经退出，将不能接收到广播。 对于自定义的广播可重写flag值，发送广播。","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"Broadcast","slug":"Broadcast","permalink":"https://batuer.github.io/tags/Broadcast/"}]},{"title":"Android动画","slug":"AndroidAnimation","date":"2018-12-18T13:34:39.073Z","updated":"2018-12-18T13:34:39.073Z","comments":true,"path":"2018/12/18/AndroidAnimation/","link":"","permalink":"https://batuer.github.io/2018/12/18/AndroidAnimation/","excerpt":"","text":"View Animation 视图动画也叫Tween(补间)动画，简单的变换(大小、位置、旋转、透明度)。 可通过XML或代码定义。 AnimationSet 动画容器管理类。 视图动画执行之后欧并未改变View的真实布局属性值，改变的是View的绘制效果。 仅支持View，支持种类少。 123456789&gt; View view1 = findViewById(R.id.view1);&gt; int type1 = Animation.RELATIVE_TO_SELF;&gt; TranslateAnimation animation1 = new TranslateAnimation(type1, 0, type1, 2f, type1, 0, type1, 0);&gt; animation1.setInterpolator(new BounceInterpolator());&gt; animation1.setRepeatCount(-1);&gt; animation1.setRepeatMode(Animation.REVERSE);&gt; animation1.setDuration(2000);&gt; view1.startAnimation(animation1);&gt; Property Animation(3.0+) 修改控件属性值实现的动画。 对象的任意属性添加动画。 动态修改属性值。 ViewPropertyAnimator属性动画扩展。 1234567&gt; View view4 = findViewById(R.id.view4);&gt; view4.animate()&gt; .translationX(200)&gt; .setInterpolator(new BounceInterpolator())&gt; .setDuration(2000)&gt; .start();&gt; ObjectAnimatior TypeEvaluator 123456&gt; //view 属性position&gt; ObjectAnimator animator = ObjectAnimator.ofObject(view, \"position\",&gt; new PointFEvaluator(), new PointF(0, 0), new PointF(1, 1));&gt; animator.setInterpolator(new LinearInterpolator());&gt; animator.setDuration(1000);&gt; PropertyValuesHolder同一个动画中改变多个属性。 12345&gt; PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(\"scaleX\", 0, 1);&gt; PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(\"scaleY\", 0, 1);&gt; PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(\"alpha\", 0, 1);&gt; ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3).start();&gt; 简单属性动画 12345678&gt; View view3 = findViewById(R.id.view3);&gt; ValueAnimator animator = ObjectAnimator.ofFloat(view3, \"translationX\", 0, 200);&gt; animator.setInterpolator(new BounceInterpolator());&gt; animator.setRepeatCount(-1);&gt; animator.setRepeatMode(ValueAnimator.REVERSE);&gt; animator.setDuration(2000);&gt; animator.start();&gt; 动画集执行顺序 1234567891011&gt; ObjectAnimator a1 = ObjectAnimator.ofFloat(view, \"alpha\", 1.0f, 0f); &gt; ObjectAnimator a2 = ObjectAnimator.ofFloat(view, \"translationY\", 0f, viewWidth); &gt; ......&gt; AnimatorSet animSet = new AnimatorSet(); &gt; animSet.setDuration(5000); &gt; animSet.setInterpolator(new LinearInterpolator()); &gt; //animSet.playTogether(a1, a2, ...); //两个动画同时执行 &gt; animSet.play(a1).after(a2); //先后执行&gt; ......//其他组合方式&gt; animSet.start(); &gt; Keyframe 12345678910&gt; Keyframe keyframe1 = Keyframe.ofFloat(0, 0); // 开始：progress 为 0&gt; Keyframe keyframe2 = Keyframe.ofFloat(0.5f, 100); // 进行到一半是，progres 为 100&gt; Keyframe keyframe3 = Keyframe.ofFloat(1, 80); // 结束时倒回到 80&gt; PropertyValuesHolder holder = PropertyValuesHolder.ofKeyframe(\"progress\", keyframe1, keyframe2, keyframe3);&gt; &gt; ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder);&gt; animator.setDuration(2000);&gt; animator.setInterpolator(new FastOutSlowInInterpolator());&gt; animator.start();&gt; 使用方式 如果是自定义控件，需要添加setter / getter方法。 用ObjectAnimator.ofXXX()创建ObjectAnimator对象。 用start()开始执行动画。 Drawable Animaton 其实就是Frame动画，幻灯片效果。 123456789&gt; &lt;!-- 注意：rocket.xml文件位于res/drawable/目录下 --&gt;&gt; &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&gt; &lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; android:oneshot=[\"true\" | \"false\"] &gt;&gt; &lt;item&gt; android:drawable=\"@[package:]drawable/drawable_resource_name\"&gt; android:duration=\"integer\" /&gt;&gt; &lt;/animation-list&gt;&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"动画","slug":"动画","permalink":"https://batuer.github.io/tags/动画/"}]},{"title":"Activity启动流程","slug":"ActivityLaunch","date":"2018-12-18T13:34:39.072Z","updated":"2018-12-18T13:34:39.072Z","comments":true,"path":"2018/12/18/ActivityLaunch/","link":"","permalink":"https://batuer.github.io/2018/12/18/ActivityLaunch/","excerpt":"","text":"https://www.jianshu.com/p/9ecea420eb52 一切从main()开始Android中，一个应用程序的开始从ActivityThread.java中的main()开始。 配置程序运行环境UserEnvironment,日志等。 准备当前线程的Looper为程序的MainLooper。 初始化ActivityThread实例 ActivityThread实例调用attach(false)，创建Application 获取MainThreadHandler MainLooper开始loop(),接收发送消息。程序开始运行。 创建Application的消息ActivityThread实例调用attach(false)，创建Application 判断是否系统程序，不同的初始化流程(分析非系统) 获得ActivityManager实例——ActivityManagerService，ActivityManagerNative.getDefault()获得代理类ActivityManagerProxy，通过ServiceManager获得IBinder实例。获取IBInder目的既是为了通过这个IBinder和ActivityManager进行通讯。 12345IBinder b = ServiceManager.getService(\"activity\");if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b);&#125;IActivityManager am = asInterface(b); 123456789101112static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj); &#125; ActivityManagerProxy.attachApplication(mAppThread) 12345678Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app.asBinder()); mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data,reply,0); reply.readException(); data.recycle(); reply.recycle(); 调用IBInder实例的tansact()方法，把参数app放到data中，最终传递给ActivityManager。 IActvitymanager的实现类ActivityManagerProxy。 ApplicationThread mAppThread ？ 12private class ApplicationThread extends ApplicationThreadNative &#123;&#125; 123public abstract class ApplicationThreadNative extends Binder implements IApplicationThread &#123; &#125; 123public interface IApplicationThread extends IInterface &#123; String descriptor = \"android.app.IApplicationThread\";&#125; ​ ActivityThread 中的常量，不希望中途被修改。 ApplicationThread是ActivityThread内部类。 ApplicationThreadNative继承Binder实现IApplicationThread。 ApplicationThread作为IApplicationThread实例承担了最后发送Activity生命周期、及其它一些任务。ApplicationThread传到ActivityManager中为了让系统根据情况控制。 ​ ActivityManagerService调度发送初始化消息12public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123;&#125; 123public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;&#125; 获得ActivityManager实例——ActivityManagerService 123456final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; 实现类ActivityManagerService 123456789@Override public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125; &#125; attachApplicationLocked() 123456789private final boolean attachApplicationLocked(IApplicationThread thread,int pid) &#123; // 以前存在 pid // If the app is being launched for restore or full backup, set it up specially ... //实现类ApplicationThread 执行bindApplication初始化Application thread.bindApplication(...); ... return true; &#125; 12345678910public final void bindApplication(...) &#123; if (services != null) &#123; // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); ... sendMessage(H.BIND_APPLICATION, data); &#125; 123456case BIND_APPLICATION: AppBindData data = (AppBindData)msg.obj; //重要 handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);break; 123456789101112131415private void handleBindApplication(AppBindData data) &#123; ... //通过反射初始化一个Instrumentation仪表。 mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()) .newInstance(); ... //通过LoadedApp命令创建Application实例 Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... mInstrumentation.callApplicationOnCreate(app); //让仪器调用Application的onCreate()方法 ...&#125; Instrumentation ? Instrumentation会在应用程序的任何代码运行之前被实例化，它能够允许你监视应用程序和系统的所有交互。 收集AndroidManifest.xml标签信息 Apllication的创建，Activity的创建，以及生命周期都会经过这个对象去执行。简单点说，就是把这些操作包装了一层。通过操作Instrumentation进而实现上述的功能。 123public void callApplicationOnCreate(Application app) &#123; app.onCreate(); &#125; LoadedApk就是data.info1234567891011121314public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; ... String appClass = mApplicationInfo.className; //Application的类名。明显是要用反射了。 ... ContextImpl appContext = ContextImpl.createAppContext(mActivityThread , this); //留意下Context app = mActivityThread.mInstrumentation .newApplication( cl, appClass, appContext); //通过仪表创建Application ...&#125; 在取得Application的实际类名之后，最终的创建工作还是交由Instrumentation去完成，就像前面所说的一样。 回Instrumentation1234567static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = (Application)clazz.newInstance(); app.attach(context); return app; &#125; LaunchActivity当Application初始化完成后，系统会根据Manifests中的配置启动Activity发送一个Intent去启动相对应的Activity。 12345678910111213141516171819202122232425262728293031323334353637 // we use token to identify this activity without having to send the// activity itself back to the activity manager. (matters more with ipc)@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); //启动Activity sendMessage(H.LAUNCH_ACTIVITY, r); &#125; H 接收到LAUNCH_ACTIVITY的消息，开始初始化Activity，ActivityThread.handleLaunchActivity() 12345678910private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; // gc、Profiler、Config、WindowManagerGlobal //... Activity a = performLaunchActivity(r,customIntent); if (a != null) &#123; //Config... //onResume handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); &#125; performLaunchActivity() 1234567891011121314151617181920212223242526272829private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //Instrumentation 创建Activity Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //反射创建Activity实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); &#125; catch (Exception e) &#123; &#125; //获取Application，r.packageInfo就是LoadApk try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; //... activity.attach( appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor,window); //持久化 Instrumentation执行Activity的onCreate() //Mainfiset下Activity标签 // ersistableMode == persistAcrossReboots if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate( activity,r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate( activity, r.state); &#125; //... return activity; &#125; Application 创建完成，第一个Activity创建完成。","categories":[{"name":"Activity","slug":"Activity","permalink":"https://batuer.github.io/categories/Activity/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"https://batuer.github.io/tags/Activity/"}]},{"title":"","slug":"DesignPattern","date":"2018-12-18T03:46:52.127Z","updated":"2018-12-18T03:46:52.127Z","comments":true,"path":"2018/12/18/DesignPattern/","link":"","permalink":"https://batuer.github.io/2018/12/18/DesignPattern/","excerpt":"","text":"策略模式定义 分离、封装算法，相互替换。 OCP原则，单一原则。 算法独立于客户端独立变化。 策略由客户端决定。 场景 一类型问题，多种处理方式。 优点 结构清晰，简单直观。 耦合度低，可扩展性好。 缺点 策略增加，子类相应增多。 UML 代码12345678910111213141516171819202122//Contextpublic class Context &#123; private IStragety mIStragety; public void setIStragety(IStragety IStragety) &#123; mIStragety = IStragety; &#125; public void doSth() &#123; &#125;&#125;//Stragetypublic interface IStragety &#123; void doSth();&#125;//Stragety implpublic class AStragety implements IStragety &#123; @Override public void doSth() &#123; System.out.println(\"A doSth\"); &#125;&#125; 策略模式与工厂模式的却别 策略模式 工厂模式 创建型设计模式 行为型设计模式 关注对象创建 关注行为选择 黑盒子（不知道具体的实现过程） 白盒子（知道具体实现过程） 状态模式定义 对象的内在状态改变时允许改变其行为。 场景 对象的行为取决于对象的状态。 不同状态对同一行为不同的响应。 优点 特定状态相关的行为放入同一个状态对象中。 结构清晰，可扩展性、可维护性高。 缺点 增加系统类和对象的个数。 UML 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface UserState &#123; /** * 转发 */ void forward(Context context); /** * 评论 * @param context */ void comment(Context context);&#125;public class LoginState implements UserState &#123; @Override public void forward(Context context) &#123; Toast.makeText(context, \"转发微博\", Toast.LENGTH_SHORT) .show(); &#125; @Override public void comment(Context context) &#123; Toast.makeText(context, \"评论微博\", Toast.LENGTH_SHORT) .show(); &#125;&#125;public class LogoutState implements UserState &#123; @Override public void forward(Context context) &#123; gotoLogin(context); &#125; @Override public void comment(Context context) &#123; gotoLogin(context); &#125; private void gotoLogin(Context context) &#123; context.startActivity(new Intent(context, LoginActivity.class)); &#125;&#125;public class LoginContext &#123; public static LoginContext getInstance() &#123; return LoginContextHolder.loginContext; &#125; private static final class LoginContextHolder &#123; private static final LoginContext loginContext = new LoginContext(); &#125; private LoginContext() &#123; &#125; UserState mState = new LogoutState(); public void setState(UserState state) &#123; mState = state; &#125; public void forward(Context context) &#123; mState.forward(context); &#125; public void comment(Context context) &#123; mState.comment(context); &#125;&#125; 策略模式、状态模式、模板模式对比 策略模式 状态模式 模板模式 定义 定义封装算法，可以相互替换，算法独立于客户端独立变化。 对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类 。 定义算法框架，一些步骤延迟到子类中，使得算法结构不变化可以重定义算法。 场景 一类型问题，多种处理方式 不同的状态对不同的行为有不同的响应。 一次性实现算法框架不变的部分，子类可改变行为。 动机 算法分离 状态改变行为 多种输出模板 驱动行为的改变 状态模式：状态的变化是由Context或State自己管理。 策略模式：由客户端提供策略。 模板模式：具体子类自己决定是否变化。 模板模式定义 一个算法框架，一些步骤延迟到子类中，使得子类可以不改变算法的结构重实现特定步骤。 关键步骤、执行顺序、具体步骤实现会随环境变化。 场景 多个子类有公有的方法并且逻辑基本相同，有一定的执行顺序，具体步骤实现会随环境变化。 优点 封装不变部分，扩展可变部分。 提取公共部分，便于维护。 缺点 阅读理解难度 UML 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class AbsComputer &#123; protected void powerOn() &#123; System.out.println(\"开机\"); &#125; protected void checkHardWare() &#123; System.out.println(\"检查硬件\"); &#125; protected void loadOs() &#123; System.out.println(\"载入系统\"); &#125; protected void login() &#123; System.out.println(\"登录\"); &#125; public final void startUp() &#123; System.out.println(\"开机 Start\"); powerOn(); checkHardWare(); loadOs(); login(); System.out.println(\"开机 End\"); &#125;&#125;public class NormalComputer extends AbsComputer &#123; @Override protected void login() &#123; super.login(); System.out.println(\"普通电脑账户密码校验\"); &#125;&#125;public class MilitaryComputer extends AbsComputer &#123; @Override protected void checkHardWare() &#123; super.checkHardWare(); System.out.println(\"特殊检查防火墙\"); &#125; @Override protected void login() &#123; super.login(); System.out.println(\"指纹人脸特殊验证\"); &#125;&#125; 单例模式定义 一个类只有一个实例（多线程下、反序列化不重建）。 构造函数private。 场景 new对象消耗过多的资源。 优点 只有一个实例，减少内存开支。 频繁创建销毁时，减少性能开销。 优化共享资源的访问。 缺点 没有接口，扩展困难。 内存泄漏隐患。 UML 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Singleton1 &#123; //volatile 顺序 private static volatile Singleton1 sSingleton1; private Singleton1() &#123; //no instance &#125; public static Singleton1 getInstance() &#123; if (sSingleton1 == null) &#123; synchronized (Singleton1.class) &#123; if (sSingleton1 == null) &#123; sSingleton1 = new Singleton1(); &#125; &#125; &#125; return sSingleton1; &#125; &#125;//推荐 第一次调用加载public class Singleton2 &#123; private Singleton2() &#123; //no instance &#125; public static Singleton2 getInstance() &#123; return Holder.single; &#125; private static final class Holder &#123; private static final Singleton2 single = new Singleton2(); &#125;&#125;public enum Singleton3 &#123; //线程安全 SINGLETON_3; public void doSth() &#123; &#125;&#125; //反序列化 private Object readResolve() throws ObjectStreamException &#123; return Holder.single; &#125; Builder模式定义 复杂对象的构建与它的表示分离。 场景 相同的方法，不同的执行顺序，产生不同的事件结果。 复杂对象的构建，参数多，且参数可以有默认值。 优点 良好的封装性，客户端不必知道内部组成的细节。 建造者独立，扩展性强。 缺点 多余的Builder对象以及Director对象，消耗内存。 UML 代码123456789101112131415161718192021222324252627282930313233343536373839public class Computer &#123; private String mBoard; private String mDisplay; private String mOS; private Computer(Builder builder) &#123; mBoard = builder.mBoard; mDisplay = builder.mDisplay; mOS = builder.mOS; &#125; public static final class Builder &#123; private String mBoard; private String mDisplay; private String mOS; public Builder() &#123; &#125; public Builder mBoard(String val) &#123; mBoard = val; return this; &#125; public Builder mDisplay(String val) &#123; mDisplay = val; return this; &#125; public Builder mOS(String val) &#123; mOS = val; return this; &#125; public Computer build() &#123; return new Computer(this); &#125; &#125;&#125; 原型模式定义 Clone创建新的对象。 场景 new对象消耗资源。 new对象需要繁琐的准备或访问权限。 优点 内存中二进制流的拷贝，比new对象性能好。 缺点 内存中拷贝，不执行构造函数。 UML 代码12345678910111213141516171819202122232425262728293031323334public class User implements Cloneable &#123; public int age; public String name; public String phoneNum; public Address address;//深拷贝（浅拷贝数据修改对应同一堆内存地址） @Override protected User clone() &#123; User clone = null; try &#123; clone = (User) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125;public class Address &#123; public String city; public String district; public String street; @Override protected Address clone() &#123; Address clone = null; try &#123; clone = (Address) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125; 工厂方法模式定义 定义一个用于创建对象的接口，子类决定实例化那个类。 场景 任何需要生成复杂对象的地方。 new就可以创建的对象无需使用工厂模式。 优点 生成复杂对象方便快捷。 缺点 添加新产品时繁琐，复杂化。 UML 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//产品类public abstract class IOHandler &#123; /** * add */ public abstract void add(String id, String name); /** * remove */ public abstract void remove(String id, String name); /** * update */ public abstract void update(String id, String name); /** * query */ public abstract void query(String id, String name);&#125; public class IOFactory &#123; public static &lt;T extends IOHandler&gt; T getIOHandler(Class&lt;T&gt; clz) &#123; IOHandler handler = null; try &#123; handler = (IOHandler) Class.forName(clz.getName()) .newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) handler; &#125;&#125; public class DBHandler extends IOHandler &#123; @Override public void add(String id, String name) &#123; &#125; @Override public void remove(String id, String name) &#123; &#125; @Override public void update(String id, String name) &#123; &#125; @Override public void query(String id, String name) &#123; &#125;&#125; 抽象工厂模式定义 创建一组相关或是相互依赖的对象提供一个接口，不需要指定具体的类。（产品是抽象的） 场景 不同抽象产品在不同环境下同一表现行为。 优点 分离接口与实现。 客户端不关系具体产品的实现（面向接口）。 缺点 类文件增加。 难以扩展新产品。 UML 代码123456789101112131415161718192021222324252627282930313233/** * 抽象工厂 */public abstract class CarFactory &#123; public abstract ITire createTire();&#125;/** * 具体工厂 */public class Q3Car extends CarFactory &#123; @Override public ITire createTire() &#123; return new NormalTire(); &#125;&#125;/** * 抽象产品 */public interface ITire &#123; void tire();&#125; /** * 具体产品 */public class NormalTire implements ITire &#123; @Override public void tire() &#123; System.out.println(\"normal createTire\"); &#125;&#125; 责任链模式定义 多个对象都有机会处理请求（避免请求接收者和发送者之间的耦合关系），将这些对象连城一条链，并沿着这条链传递请求，直到有对象处理该请求。 场景 多个对象处理同一请求，具体哪个对象处理则在运行时动态决定。 优点 请求者和处理者解耦，提高代码灵活性。 缺点 处理者太多，遍历影响性能。 UML代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 抽象处理者 */public abstract class AbsHandler &#123; protected AbsHandler nextHandler; protected abstract void handle(AbsReq req); protected abstract int getHandleLevel(); public final void handleReq(AbsReq req) &#123; if (getHandleLevel() == req.getLevel()) &#123; handle(req); &#125; else &#123; if (nextHandler != null) &#123; nextHandler.handleReq(req); &#125; else &#123; System.out.println(\"no next handler\"); &#125; &#125; &#125;&#125;/** * 具体处理者 */public class Handler1 extends AbsHandler &#123; @Override protected void handle(AbsReq req) &#123; System.out.println(\"handler1 \"); &#125; @Override protected int getHandleLevel() &#123; return 1; &#125;&#125;/** * 抽象请求 */public abstract class AbsReq &#123; protected Object obj;//处理请求 protected abstract int getLevel(); public AbsReq(Object obj) &#123; this.obj = obj; &#125; public Object getObj() &#123; return obj; &#125;&#125;/** * 具体请求 */public class Req extends AbsReq &#123; public Req(Object obj) &#123; super(obj); &#125; @Override protected int getLevel() &#123; return 1; &#125;&#125; 解释器模式定义场景优点缺点UML代码责任链模式定义场景优点缺点UML代码","categories":[],"tags":[]},{"title":"","slug":"Message","date":"2018-09-24T15:58:40.172Z","updated":"2018-09-24T15:58:40.172Z","comments":true,"path":"2018/09/24/Message/","link":"","permalink":"https://batuer.github.io/2018/09/24/Message/","excerpt":"","text":"原理-","categories":[],"tags":[]},{"title":"HTTP、HTTPS、SOCKET、TCP、UDP","slug":"HTTP、HTTPS、Socket、TCP、UDP","date":"2018-09-14T16:52:13.138Z","updated":"2018-09-24T12:36:53.315Z","comments":true,"path":"2018/09/15/HTTP、HTTPS、Socket、TCP、UDP/","link":"","permalink":"https://batuer.github.io/2018/09/15/HTTP、HTTPS、Socket、TCP、UDP/","excerpt":"","text":"HTTP(Hypertext Transfer Protocol)特点 基于TCP/IP通信协议传递数据。 简单快速：协议简单，短链接发送请求接收数据。 灵活：传输任意类型数据对象，由Content-Type标记数据类型。 短链接： HTTP1.0：一次TCP链接，处理完本次请求后，自动释放链接。 HTTP1.1：一次TCP链接处理多个请求，且多个请求可重叠进行，自动释放链接，减少TCP三次握手开销。 无状态协议：对于事物处理没有记忆能力。 只能客户端主动请求，服务器不能主动发送。 ######组成 请求行：用来说明请求类型，要访问的资源以及使用的HTTP版本。 请求头：紧接着请求行之后的部分，用来说明服务器要使用的附近信息。 空行：请求后面的空行是必须的。 请求体：请求数据，任意数据，可为空。 状态码 1xx（指示消息）：请求已接收，继续处理。 2xx（成功）：请求已成功接收。 3xx（重定向）：要完成请求必须更进一步的操作。 4xx（客户端错误）：请求有语法错误或请求无法实现。 400（Bad Request）：服务器无法理解的请求。 401（Unauthorized）：未经授权。 403（Forbidden）：服务器接收到请求，拒绝提供服务。 404（Not Found）：请求资源不存在，错误的URL。 5xx（服务端错误）：服务器未能实现客户端的请求。 500（Internal Server Error）：服务器发生不可知的错误。 503（Server Unavailable）：服务器不能处理请求。 更多状态码 工作原理 用域名访问服务器，先向DNS服务器请求解析IP地址。 用IP地址和端口和服务器建立TCP连接。 向服务器发送Http请求。 服务器响应请求。 释放TCP连接。 若connection模式为close，则服务器主动关别TCP连接，客户端被动关闭连接，释放TCP连接。 若connection模式为keepalive，则连接会继续保持一段时间，在该时间段内可以继续接收请求。 GET和POST区别 请求数据 GET请求的数据附加在URL之后，有长度限制（限制和浏览器有关）。 POST请求的数据在请求体里。 提交数据安全性 POST在请求体里安全高于GET在URL里。 HTTPS（Hypertext Transfer Protocol over Secure Socket Layer）特点 安全版HTTP，即H赛用安全套接字层（SSL/TLS）进行信息交互。 工作原理 准备流程，从CA证书机构，获取数字证书 服务器生成一对公私钥S.pub、S.pri，私钥服务器保留（用于解密和签名），将公钥S.pub，身份信息，传给CA机构。 CA机构也有公私钥C.pub、C.pri，由S.pub、身份信息、CA签名生成数字证书（签名使用C.prt）。 将数字证书颁发给服务器。 客户端（如浏览器）会内置一份CA根证书（包含C.pub），用于对数字证书验证。 使用流程 客户端发起请求（TCP三次握手），建立TCP连接。 客户端将支持的算法列表和产生密钥的随机数发送给服务器。 服务器返回支持的算法和CA证书。 验证证书，生成对称密钥。 通过对称密钥进行HTTP通信。 优缺点 优点 确保数据发送到正确的客户端和服务器。 防止数据在传输过程中不被窃取、改变，确保数据的完整性。 缺点 加载时间延长、影响缓存、增加数据开销和功耗。 无法避免服务器收到攻击。 CA根证书并不安全。 服务器CA证书需要购买。 证书绑定固定IP。 服务器端资源占用较多。 TCP 面向连接。传输数据建立在可靠的连接上。 传输可靠，保证数据正确性和数据有序性。 速度慢，建立连接需要开销较多（时间、系统资源）。 适用于传输大量数据（流模式）。 建立连接三次握手。 释放连接四次挥手。 ​ UDP 面向非连接，传输不需要建立连接。 传输不可靠，不保证传输的完整性和有序性。 传输少量数据（数据包模式）。 速度快。 SOCKET概念 通信的基石，是支持TCP/IP协议网络通信的基本操作单元。 包含通信必须的物种必须信息： 连接使用的协议。 本地主机的IP。 本地进程的协议端口。 远地主机的IP。 远地进程的协议端口。 建立连接 至少需要一对套接字，运行与客户端的ClientSocket和运行与服务端的ServerSocker。 连接步骤 服务器监听。 客户端请求。 连接确认。 SOCKET、TCP/IP、HTTP 建立Socket连接时，可指定使用的传输层协议（TCP或UDP）。 TCP/IP是传输层协议，解决数据如何在网络中传输。 HTTP层是应用层协议，解决如何包装数据。","categories":[{"name":"网络","slug":"网络","permalink":"https://batuer.github.io/categories/网络/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://batuer.github.io/tags/Http/"},{"name":"Socket","slug":"Socket","permalink":"https://batuer.github.io/tags/Socket/"}]},{"title":"Binder进程通信","slug":"Binder","date":"2018-09-13T16:01:03.675Z","updated":"2018-09-13T16:01:03.676Z","comments":true,"path":"2018/09/14/Binder/","link":"","permalink":"https://batuer.github.io/2018/09/14/Binder/","excerpt":"","text":"学习链接 Binder 从机制、模型的角度 定义：Binder是Android中IPC^1的一种方式。 作用：Android中跨进程通信。 模型的结构、组成 定义：Binder是一种虚拟的物理设备驱动（Binder驱动)。 作用：连接Service进程，Client进程和ServiceManager进程。 Android代码的实现 定义：Binder是一个类，实现IBinder接口。 作用：Binder机制模型，代码的形式具体实现在Android中。 进程空间划分 一个进程空间划分成用户空间与内核空间，进程内用户与内核隔离。 区别 进程间，用户空间数据不可共享。 进程间，内核空间数据可共享。 所有进程共用一个内核空间。 进程隔离Linux机制，为了保证安全性与独立性，一个进程不能直接访问另一个进程。 IPC进程间数据交互、通信。 Binder跨进程通信机制、模型模型原理Binder跨进程通信机制基于Client -Server 模式 模型组成角色 Client进程（Android客户端）：使用服务的进程。 Server进程（服务器端）：提供服务的进程。 ServiceManager进程（类似于路由器）：管理Service注册与查询（将字符形式的Binder名字转化成Client中对该Binder的引用）。 Binder驱动（持有每个Server进程在内和空间的Binder实体，并提供Client进程Binder实体的引用）： 虚拟设备驱动，是连接Servier、Client和ServiceManager的桥梁。 传递服务进程消息。 传递进程间需要传递的数据：通过内存映射。 线程控制：采用Binder线程池，并有Binder驱动自身进行管理。 原理步骤 注册服务：ServiceManager拥有Server进程的信息。 Server进程向Binder驱动发起服务注册请求。 Binder驱动将注册请求转发给ServiceManager。 ServiceManager添加该Server进程。 获取服务：（Client进程与Server进程已建立连接） Client向Binder驱动传递要获取服务的名称，获取请求服务。 Binder驱动将请求转发给ServiceManager进程。 ServiceManager通过名称查找需要的Server信息。 通过Binder驱动将上述服务信息返回给Client进程。 使用服务 Binder驱动为跨进程通信做准备——实现内存映射。 Binder驱动创建一块接收缓存区。 根据ServiceManager进程里的Server信息找到对应的Server进程，实现内核缓存区和Server进程用户空间地址同时映射到同一个接收缓存区中。 Client进程将参数数据发送到Server进程。 Client进程通过系统调用copy_from_user()发送数据到内核空间中的缓存区（当前线程被挂起）。 由于内核缓存与接收进程的用户空间地址存在映射关系（同时映射Binder创建的接收缓存区中）相当于也发送到了Server进程的用户空间地址，即Binder驱动实现了跨进程通信。 Binder驱动通知Server进程执行解包。 Server进程将参数数据发送到Serve进程。 收到BInder驱动通知后，Server进程从线程池中取出线程，进行数据解包与调用目标方法。 将最终执行结果写入到自己的共享内存中。 Server进程将目标方法的结果返回给Client进程。 将最宠执行结果写入映射的用户空间的内存区域中。 由于内核缓存区与接收进程的用户空间地址存在映射关系(同时映射Binder创建的接收缓存区中)，相当于也发送到了内核缓存区中。 Binder通知Client进程获得返回结果(此时Client进程之前被挂起的线程被重新唤醒)。 Client进程通过系统调用copy_to_user()从内核缓存区接收Server 进程返回的结果。 优点： 传输效率高，每次单项通信数据拷贝次数一次，用户空间与内核空间可直接通过共享对象直交互。 为接收进程分配了不确定大小的接收缓存区。 额外说明 Client、Server、ServiceManager进程之间的交互都必须通过Binder驱动，并非直接交互。 Client、Server、ServiceManager进程数据进程空间的用户空间，不可直接交互。 Binder驱动属于进程空间的内核空间。 Binder驱动与ServiceManager属于Android基础架构( 系统已经实现)，而Client进程和Server进程应用层，需开发者自己实现。 Binder请求的线程管理 Server进程可能会创建多个线程来处理Binder请求。 Binder模型线程管理采用Binder驱动的线程池，并由Binder驱动自身管理，非Server进程管理。 一个进程Binder线程数默认为16。 Binder机制在Android具体实现原理 Binder机制在Android中实现主要靠Binder类，其实现了IBinder接口。 注册服务 Server进程通过Binder驱动像ServiceManager进程注册服务。 Server进程创建一个Binder对象。 Binder实体是Server进程在Binder驱动中的存在形式。 Binder实体保存Server和ServiceManager的信息(保存在内核空间中)。 Binder驱动通过内核空间的Binder实体找到用户空间的Server对象。 注册服务后，Binder驱动持有Server进程创建的BInder实体。 获取服务 Client进程使用某个service前，须通过Binder驱动向ServiceManager进程获取相应的Service信息。 使用服务Client 进程获取到的Service信息(Binder代理对象)，通过Binder驱动建立与该Server所在Server进程通信的链路，并开始使用服务。 优点Linux上的其他进程通信方式(管道、消息队列、共享内存、信号量、Socker)，Binder机制的优点： 高效 Binder机制拷贝只需一次，而管道、消息队列、Socket都需两次。 通过驱动在内核空间拷贝数据，不需要额外的同步处理。 安全性高 Binder机制为每个进程分配了UUID/PID来作为鉴别身份的表示。 在Binder通信时会根据UUID/PID进行有效性检测。 传统的进程通信方式对于通信双方的身份没有做出严格的验证。 使用简单 采用Client/Server架构 实现面向对象的调用方式(即在使用BInder时，就和调用一个本地对象实例一样)","categories":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"https://batuer.github.io/tags/Binder/"}]},{"title":"RxJava2操作符","slug":"RxJava2","date":"2018-09-13T16:01:03.656Z","updated":"2018-09-13T16:01:03.656Z","comments":true,"path":"2018/09/14/RxJava2/","link":"","permalink":"https://batuer.github.io/2018/09/14/RxJava2/","excerpt":"","text":"创建基本创建 create() : 完整创建1个被观察者对象（Observable）快速创建 &amp; 发送事件 just() : 快速创建1个被观察者对象（Observable） 发送事件的特点：直接发送 传入的事件 最多只能创建10个 fromArray（）: 快速创建1个被观察者对象（Observable） 发送事件的特点：直接发送 传入的数组数据 10个以上事件 fromIterable（）: 快速创建一个被观察者对象(Observable) 发送事件的特点，直接发送传入的集合数据 发送10个以上事件延迟创建 defer(): 直到有观察者（Observer ）订阅时，才动态创建被观察者对象（Observable） &amp; 发送事件 timer(): 快速创建1个被观察者对象（Observable） 发送事件的特点：延迟指定时间后，发送1个数值0（Long类型） 本质:延迟执行onNext(0) interval(): 快速创建1个被观察者对象(Observable) 发送事件的特点:延迟初始化时间开始执行定时间隔发送事件 从0开始，递增1执行 intervalRange(): 快速创建1个被观察者对象(Observable) 发送事件的特点:类似于interval(),区别在于事件 起始值和数量有限制. range() /rangeLong() : 快速创建1个被观察者对象(Observable) 发送事件的特点: 连续发送事件，参数分别为起始值和事件数量.变换变换操作符 map(): 改变发射源的数据类型 flatMap(): 将被观察者发送的事件序列进行 拆分 &amp; 单独转换，再合并成一个新的事件序列，最后再进行发送(无序 ) 直接改变发射源 contactMap() : 类似于flatMap() 与FlatMap（）的 区别在于：拆分 &amp; 重新合并生成的事件序列 的顺序 = 被观察者旧序列生产的顺序(有序) switchMap() : switchMap的作用在flatMap的基础上，对输出结果若同时发生，只会保证最新结果而放弃旧数据。 buffer() : 定期从 被观察者（Observable）需要发送的事件中 获取一定数量的事件 &amp; 放到缓存区中，最终发送组合/合并组合多个被观察者 concat（） / concatArray（）: 组合多个被观察者一起发送数据，合并后 按发送顺序串行执行 二者区别：组合被观察者的数量，即concat（）组合被观察者数量≤4个，而concatArray（）则可＞4个 merge（） / mergeArray（）: 组合多个被观察者一起发送数据，合并后 按时间线并行执行 二者区别：组合被观察者的数量，即merge（）组合被观察者数量≤4个，而mergeArray（）则可＞4个 区别上述concat（）操作符：同样是组合多个被观察者一起发送数据，但concat（）操作符合并后是按发送顺序串行执行 concatDelayError（） / mergeDelayError（）: 使用contact或merge时，前面的某一事件发生error时终止其他观察者发送事件 用DelayError()推迟error事件至其它观察者发送完事件.合并多个事件 zip() 合并 多个被观察者（Observable）发送的事件，生成一个新的事件序列（即组合过后的事件序列），并最终发送 事件组合方式 = 严格按照原先事件序列 进行对位合并 被合并的事件都会执行完毕，最终合并的事件已最少的为基准。 combineLatest（） 当两个Observables中的任何一个发送了数据后，将先发送了数据的Observables 的最新（最后）一个数据 与 另外一个Observable发送的每个数据结合，最终基于该函数的结果发送数据 与Zip（）的区别：Zip（）= 按个数合并，即1对1合并；CombineLatest（） = 按时间合并，即在同一个时间点上合并 combineLatestDelayError() 类似于contactDelayError() reduce() 把被观察者需要发送的事件聚合成1个事件 &amp; 发送 聚合的逻辑根据需求撰写，但本质都是前2个数据聚合，然后与后1个数据继续进行聚合，依次类推 collect() 将被观察者Observable发送的数据事件收集到一个数据结构里发送事件前追加发送事件 startWitch()/startWithArray() 在一个被观察者发送事件前，追加发送一些数据 / 一个新的被观察者统计发送事件的数量 count() 统计被观察者发送的事件数量应用场景 &amp; 对应操作符详解连接被观察者 &amp; 观察者 subscribe（） 订阅，即连接观察者 &amp; 被观察者线程调度延迟操作 delay（） 使得被观察者延迟一段时间再发送事件在事件的生命周期中操作 do() 在某个事件的生命周期中调用 doOnEach 当Observable每发送1次数据事件就会调用1次.包含onNext、onError、onComplete doOnNext 执行Next事件前调用 doAfterNext 执行Next事件后调用 doOnComplete Observable正常发送事件完毕后调用 doOnError Observable发送错误事件时调用 doOnSubscribe 观察者订阅时调用 doAfterTerminate Observable发送事件完毕后调用，无论正常发送完毕 / 异常终止 doFinally 最后执行错误处理 onErrorReturn（） 遇到错误时，发送1个特殊事件 &amp; 正常终止 onErrorResumeNext（） 遇到错误时，发送1个新的Observable onErrorResumeNext（）拦截的错误 = Throwable；若需拦截Exception请用onExceptionResumeNext（） 若onErrorResumeNext（）拦截的错误 = Exception，则会将错误传递给观察者的onError方法 onExceptionResumeNext（） 遇到错误时，发送1个新的Observable onExceptionResumeNext（）拦截的错误 = Exception；若需拦截Throwable请用onErrorResumeNext（） 若onExceptionResumeNext（）拦截的错误 = Throwable，则会将错误传递给观察者的onError方法 retry() 重试，即当出现错误时，让被观察者（Observable）重新发射数据 接收到 onError（）时，重新订阅 &amp; 发送事件 Throwable 和 Exception都可拦截 retryUntil（） 出现错误后，判断是否需要重新发送数据 若需要重新发送 &amp; 持续遇到错误，则持续重试 作用类似于retry（Predicate predicate） 返回true则不重新发送数据事件 retryWhen（） 遇到错误时，将发生的错误传递给一个新的被观察者（Observable），并决定是否需要重新订阅原始被观察者（Observable）&amp; 发送事件 若返回的Observable发送的事件 = Next事件，则原始的Observable重新发送事件（若持续遇到错误，则持续重试） 返回的Observable发送的事件 = Error事件，则原始的Observable不重新发送事件,该异常错误信息可在观察者中的onError（）中获得重复发送 repeat() 无条件地、重复发送 被观察者事件 repeatWhen（） 有条件地、重复发送 被观察者事件 若新被观察者（Observable）返回1个Complete（） / Error（）事件，则不重新订阅 &amp; 发送原来的 Observable 若新被观察者（Observable）返回其余事件，则重新订阅 &amp; 发送原来的 Observable","categories":[{"name":"RxJava2","slug":"RxJava2","permalink":"https://batuer.github.io/categories/RxJava2/"}],"tags":[{"name":"RxJava2","slug":"RxJava2","permalink":"https://batuer.github.io/tags/RxJava2/"}]},{"title":"AsyncTask","slug":"AsyncTask","date":"2018-04-13T00:10:25.831Z","updated":"2018-04-13T00:27:55.427Z","comments":true,"path":"2018/04/13/AsyncTask/","link":"","permalink":"https://batuer.github.io/2018/04/13/AsyncTask/","excerpt":"","text":"AsyncTask AsyncTask 是 Android 中一个异步处理的框架，它内部集成了线程池和 Handler 机制，实现了异步任务加载和主线程更新 UI 的功能，在 Android 中不同的版本的 AsyncTask 却有点不一样。 Android中工作者线程主要有AsyncTask、IntentService、HandlerThread，它们本事上都是对线程或线程池的封装。(ThreadPoolExecutor) 使用简介 AsyncTask是对Handler与线程池的封装。AsyncTask内部包含一个Handler，方便更新UI。使用线程池 onPreExecute() //此方法会在后台任务执行前被调用，用于进行一些准备工作 doInBackground(Params… params) //此方法中定义要执行的后台任务，在这个方法中可以调用publishProgress来更新任务进度（publishProgress内部会调用onProgressUpdate方法） onProgressUpdate(Progress… values) //由publishProgress内部调用，表示任务进度更新 onPostExecute(Result result) //后台任务执行完毕后，此方法会被调用，参数即为后台任务的返回结果 onCancelled() //此方法会在后台任务被取消时被调用 以上方法中，除了doInBackground方法由AsyncTask内部线程池执行外，其余方法均在主线程中执行。 局限性 Android4.1之前AsyncTask类必须在主线程中加载。 在Android 4.1以及以上版本则不存在这一限制，因为ActivityThread（代表了主线程）的main方法中会自动加载AsyncTask 。 一个AsyncTask对象只能调用一次execute方法。","categories":[{"name":"AsyncTask","slug":"AsyncTask","permalink":"https://batuer.github.io/categories/AsyncTask/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://batuer.github.io/tags/Android/"},{"name":"AsyncTask","slug":"AsyncTask","permalink":"https://batuer.github.io/tags/AsyncTask/"}]},{"title":"ExecutorService和Executors","slug":"Executor","date":"2018-04-13T00:10:25.831Z","updated":"2018-04-13T00:10:25.831Z","comments":true,"path":"2018/04/13/Executor/","link":"","permalink":"https://batuer.github.io/2018/04/13/Executor/","excerpt":"","text":"1. newFixedThreadPool 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。 该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。 newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。 其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子 。 和cacheThreadPool不同，FixedThreadPool没有IDLE机制，所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器 。 从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同。 fixed池线程数固定，并且是0秒IDLE（无IDLE），cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE。 重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。 固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。 超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的） 使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。 源码分析：从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同： fixed池线程数固定，并且是0秒IDLE（无IDLE）。 cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE。 2. newCachedThreadPool 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。 该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。 缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中 。 缓存型池子通常用于执行一些生存期很短的异步型任务。 能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。 注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。 重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。 使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。 超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。 结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。 3. newSingleThreadExecutor 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。 该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。 单例线程，任意时间池中只能有一个线程 。 用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）。 SingleThreadExecutor得到的是一个单个的线程，这个线程会保证你的任务执行完成。 如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。 4. newScheduledThreadPool 调度型线程池，这个池子里的线程可以按schedule依次delay执行，或周期执行。 该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。 ScheduledThreadPool是一个固定大小的线程池，与FixedThreadPool类似，执行的任务是定时执行。 5. Android性能优化之使用线程池处理异步任务 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失。 大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM。 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿。 6. 使用线程池管理线程的优点 ExecutorService是一个接口，线程池服务。 hreadPoolExecutor实现ExecutorService接口封装了一系列API是的它具有线程池的特性，包括工作队列，核心线程池数，最大线程池数。 管理线程，节省内存资源，减小消耗。 7. shutdown()和shutdownNow()的区别 shutdown()方法在终止前允许执行以前提交的任务。不再接受新的任务。 shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。","categories":[{"name":"Executors","slug":"Executors","permalink":"https://batuer.github.io/categories/Executors/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://batuer.github.io/tags/线程/"},{"name":"Executors","slug":"Executors","permalink":"https://batuer.github.io/tags/Executors/"}]},{"title":"Dart","slug":"Dart","date":"2018-04-13T00:10:25.831Z","updated":"2018-04-13T00:10:25.831Z","comments":true,"path":"2018/04/13/Dart/","link":"","permalink":"https://batuer.github.io/2018/04/13/Dart/","excerpt":"","text":"Dart基础学习。List 固定长度的列表，一旦定义无法改变。 12345678910void _fixedList() &#123; List&lt;int&gt; list = new List(3); list[0] = 0; list[1] = 1; for (var value in list) &#123; print('Fire:' + value.toString()); &#125; //错误:Unsupported operation: Cannot add to a fixed-length list //list.add(4); &#125; 可变长度，动态加减。 1234567891011void _growableList() &#123; List&lt;int&gt; list = [0, 1]; print('Fire:' + list[1].toString()); list[1] = 11; print('Fire:' + list[1].toString()); //add list.add(3); for (var value in list) &#123; print('Fire:DartTest:29:' + value.toString()); &#125; &#125; 几种构造。 123456789101112// 创建固定长度的列表 List fixedLengthList = new List(3);// 创建可改变长度的列表 List growableListA = new List();// 创建包含所有元素的固定长度列表 List fixedLengthListB = new List.unmodifiable([1, 2, 3]);// 创建包含所有元素的可改变长度列表 List growableListC = new List.from([1, 2, 3]);// 用生成器给所有元素赋初始值 List fixedLengthList = new List&lt;int&gt;.generate(4, (int index) &#123; return index * index; &#125;); 排序。 123456789101112131415void _listSort() &#123; List&lt;int&gt; list = [1, 3, 2, 5, 6, 7, 4]; list.sort((a, b) &#123; return a.compareTo(b); &#125;); print('Fire:DartTest:47:' + list.join(\",\")); list.sort((a, b) &#123; return a - b; &#125;); print('Fire:DartTest:51:' + list.join(\",\")); list.sort((a, b) &#123; return b - a; &#125;); print('Fire:DartTest:55:' + list.join(\",\")); &#125; Map 键值对，每个键对应一个值。 几种构造。 12345678910111213141516171819202122232425262728293031void _map() &#123; // Map&lt;String, int&gt; map = &#123;\"a\": 1, \"b\": 2&#125;; print('DartTest:62:' + map.keys.join(\",\") + \":\" + map.values.join(\",\")); map.addAll(&#123;\"c\": 3&#125;); print('DartTest:65:' + map.keys.join(\",\") + \":\" + map.values.join(\",\")); map.addAll(&#123;\"a\": 11&#125;); print('DartTest:67:' + map.keys.join(\",\") + \":\" + map.values.join(\",\")); // Map&lt;String, int&gt; map1 = Map.castFrom(map); print('DartTest:70:' + map1.keys.join(\",\") + \":\" + map1.values.join(\",\")); // List&lt;MapEntry&lt;String, int&gt;&gt; list = [ new MapEntry(\"a\", 1), new MapEntry(\"b\", 2) ]; Map&lt;String, int&gt; mapFromEntries = new Map.fromEntries(list); // List&lt;String&gt; list1 = [\"4\", \"5\"]; List&lt;int&gt; list2 = [1, 2]; var map2 = new Map.fromIterables(list1, list2); print('DartTest:82:' + map2.keys.join(\",\") + map2.values.join(\",\")); Map&lt;String, String&gt; map3 = new Map.fromIterable(list1, key: (item) =&gt; item, value: (item) =&gt; item); Map&lt;String, String&gt; map4 = new Map.fromIterable(list2, key: (item) &#123; item.toString(); &#125;, value: (item) &#123; item.toString(); &#125;); &#125; Set 每个对象只能出现一次，不能重复。 命名参数 用 { } 把参数包装起来，就能标识命名参数。 用 : 指定默认值。 1234567891011void test() &#123; _parameter(name: \"xiaoming\", age: 11); _parameter(name: \"xiaoming\", age: 11, sex: \"woman\"); _parameter1(\"小明\", 22, \"man\"); &#125; //用 &#123; &#125; 把参数包装起来，就能标识命名参数。 //用 : 指定默认值 void _parameter(&#123;String name, int age, String sex: 'man'&#125;) &#123;&#125; void _parameter1(String name, int age, String sex) &#123;&#125; 位置参数 用[ ] 把参数包括起来，标示参数位置 用=指定默认值 123456789101112131415161718192021222324252627void test() &#123; _parameterPos(\"小明\", \"11\"); _parameterPos(\"小明\", \"11\", \"sex\", 11); &#125; // 用 [ ] 把参数包装起来，就能标识位置参数 // 用 = 指定默认值 void _parameterPos(String name, String age, [String sex, int height]) &#123; StringBuffer sb = new StringBuffer(); sb.write(\"name_\"); if (name != null) &#123; sb.write(name); &#125; sb.write(\" age_\"); if (age != null) &#123; sb.write(age); &#125; sb.write(\" sex_\"); if (sex != null) &#123; sb.write(sex); &#125; sb.write(\" height_\"); if (height != null) &#123; sb.write(height); &#125; print('Fire:DartTest:27:' + sb.toString()); &#125; 高阶函数 将一个函数当作参数传递。 123456789101112void test() &#123; List&lt;String&gt; list = [\"a\", \"b\"]; list.forEach((item) &#123; _printElement(item); &#125;); list.forEach(_printElement); &#125; //将一个函数当作参数传递 void _printElement(Object obj) &#123; print('Fire:DartTest:11:' + obj.toString()); &#125; 将一个函数分配给变量。 12345void test() &#123; //将一个函数分配给一个变量 var loudify = (msg) =&gt; \"将一个函数分配给一个变量:$&#123;msg.toUpperCase()&#125;\"; print('Fire:DartTest:14:' + loudify('hello')); &#125; 闭包函数 dart的闭包就是函数对象，其实跟JavaScript的闭包函数差不多，理论请参考JavaScript的闭包函数。 123456789void test() &#123; var makeAddBy2 = makeAddBy(num: 2); var makeAddBy3 = makeAddBy(num: 3); print('Fire:DartTest:9:' + makeAddBy3(5).toString()); print('Fire:DartTest:8:' + makeAddBy2(3).toString()); &#125; Function makeAddBy(&#123;int num&#125;) &#123; return (int i) =&gt; i + num; &#125; 泛型 dart中所有基本类型数组和列表都是泛型，这样可以提高代码的可读性。 减少代码。 提前检查。 异常 dart会抛出并捕获异常，如果没有捕获异常，就会中断运行或结束程序。 与Java不同的是dart的所有异常都是未经检查的。 dart提供了Exception、Error类型，以及更多的子类型，也可以自定义异常。 1234567891011121314151617181920212223242526void _exception() &#123;// //// if (true) &#123;// throw new Exception(\"异常\");// &#125;// //自定异常// if (true) &#123;// throw \"自定义异常\";// &#125; //捕获并处理 try &#123; if (true) &#123; throw new Exception(\"异常\"); &#125; &#125; on Exception &#123; print('Fire:DartTest:24:' + '捕获异常'); &#125; // try &#123; if (true) &#123; throw new Exception(\"异常\"); &#125; &#125; on Exception catch (e) &#123; print('Fire:DartTest:24:' + '捕获异常:' + e.toString()); &#125; finally &#123;&#125; &#125; 实例变量 声明实例变量，未初始化为null。 构造函数 默认无参构造。 命名构造。 1DartTest.fromJson(String json) &#123;&#125; 子类构造函数调用父类的默认构造函数，如果父类没有默认构造函数，必须手动调用父类的构造函数。 重定向构造。 123DartTest(&#123;int a&#125;) &#123;&#125; DartTest.fromJson(int b) : this(a: b); 常量构造。声明const 构造，并且确保实例变量是final的。 1234//常量构造 const DartTest(); static final DartTest dartTest = new DartTest(); 抽象类 使用abstract修饰符定义的抽象类不能被实例化。 用于定义接口。 有抽象方法的一定是抽象类，反之则不然。 隐式接口 每个类都有一个隐式定义的接口，包含所有非私有方法和变量。 implements 实现一个或多个接口。 1234567891011121314151617181920class Person &#123; final _name; int height; int _width; Person(this._name); String greet(who) =&gt; \"Hello, $who. I am $_name.\"; void _test()&#123;&#125;&#125;class PersonIml implements Person &#123; @override// String greet(who) =&gt; \"-------\"; String greet(who) &#123; return \"-----\"; &#125; @override int height;&#125;","categories":[{"name":"Dart","slug":"Dart","permalink":"https://batuer.github.io/categories/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://batuer.github.io/tags/Dart/"}]}]}